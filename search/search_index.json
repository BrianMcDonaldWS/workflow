{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"workflow \u00b6 A unidirectional data flow library for Kotlin and Swift, emphasizing: Strong support for state-machine driven UI and navigation. Composition and scaling. Effortless separation of business and UI concerns. This project is currently experimental and the API subject to breaking changes without notice. Follow Square\u2019s engineering blog, The Corner , to see when this project becomes stable. While the API is not yet stable, this code is in heavy production use in Android and iOS apps with millions of users. Using Workflows in your project \u00b6 Swift \u00b6 Swift Package Manager \u00b6 If you are developing your own package, be sure that Workflow is included in dependencies in Package.swift : 1 2 3 dependencies : [ . package ( url : \"git@github.com:square/workflow.git\" , from : \"0.21.1\" ) ] In Xcode 11+, add Workflow directly as a dependency to your project with File > Swift Packages > Add Package Dependency... . Provide the git URL when prompted: git@github.com:square/workflow.git . Cocoapods \u00b6 If you use CocoaPods to manage your dependencies, simply add Workflow and WorkflowUI to your Podfile: 1 2 pod 'Workflow' pod 'WorkflowUI' Kotlin \u00b6 Quick Start \u00b6 To get started with a fresh, barebones, Workflow-based Android app, we\u2019ve created a template repository \u2013 just click \u201cUse this template\u201d to create a new repository with a simple but runnable app: github.com/square/workflow-android-template Maven Artifacts \u00b6 Artifacts are hosted on Maven Central. If you\u2019re using Gradle, ensure mavenCentral() appears in your repositories block, and then add dependencies on the following artifacts: Maven Coordinates Depend on this if\u2026 com.squareup.workflow:workflow-core-jvm:x.y.z You are writing a library module/project that uses Workflows, but you don't need to interact with the runtime from the outside. com.squareup.workflow:workflow-rx2:x.y.z You need to interact with RxJava2 from your Workflows. com.squareup.workflow:workflow-testing-jvm:x.y.z You are writing tests. This should only be included as a test dependency. com.squareup.workflow:workflow-ui-core-android:x.y.z You're writing an Android app that uses Workflows. com.squareup.workflow:workflow-ui-modal-android:x.y.z Your Android app uses modals (popups). com.squareup.workflow:workflow-ui-backstack-android:x.y.z Your android app uses backstacks. Lower-level Artifacts \u00b6 Most code shouldn\u2019t need to depend on these directly. They should generally only be used to build higher-level integrations with UI frameworks. Maven Coordinates Depend on this if\u2026 com.squareup.workflow:workflow-runtime-jvm:x.y.z You need to interact directly with the runtime, i.e. streams of renderings and outputs. com.squareup.workflow:workflow-ui-core-jvm:x.y.z You are writing workflow-ui-android for another UI framework. Defines the core types used by that artifact. Resources \u00b6 Square Workflow \u2013 Droidcon NYC 2019 ( slides ) SF Android GDG @ Square 2019 - Hello Workflow (live coding) Android Dialogs 5-part Coding Series 1 , 2 , 3 , 4 , 5 Reactive Workflows a Year Later \u2013 Droidcon NYC 2018 The Reactive Workflow Pattern \u2013 Fragmented Podcast The Reactive Workflow Pattern Update \u2013 Droidcon SF 2017 The Rx Workflow Pattern \u2013 Droidcon NYC 2017 ( slides ) Support & Contact \u00b6 Workflow maintainers hang out in the #squarelibraries channel on the Kotlin Slack and the #square-libraries-wtf channel on the Android Study Group Slack. Releasing and Deploying \u00b6 See RELEASING.md . License \u00b6 Copyright 2019 Square Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#workflow","text":"A unidirectional data flow library for Kotlin and Swift, emphasizing: Strong support for state-machine driven UI and navigation. Composition and scaling. Effortless separation of business and UI concerns. This project is currently experimental and the API subject to breaking changes without notice. Follow Square\u2019s engineering blog, The Corner , to see when this project becomes stable. While the API is not yet stable, this code is in heavy production use in Android and iOS apps with millions of users.","title":"workflow"},{"location":"#using-workflows-in-your-project","text":"","title":"Using Workflows in your project"},{"location":"#swift","text":"","title":"Swift"},{"location":"#swift-package-manager","text":"If you are developing your own package, be sure that Workflow is included in dependencies in Package.swift : 1 2 3 dependencies : [ . package ( url : \"git@github.com:square/workflow.git\" , from : \"0.21.1\" ) ] In Xcode 11+, add Workflow directly as a dependency to your project with File > Swift Packages > Add Package Dependency... . Provide the git URL when prompted: git@github.com:square/workflow.git .","title":"Swift Package Manager"},{"location":"#cocoapods","text":"If you use CocoaPods to manage your dependencies, simply add Workflow and WorkflowUI to your Podfile: 1 2 pod 'Workflow' pod 'WorkflowUI'","title":"Cocoapods"},{"location":"#kotlin","text":"","title":"Kotlin"},{"location":"#quick-start","text":"To get started with a fresh, barebones, Workflow-based Android app, we\u2019ve created a template repository \u2013 just click \u201cUse this template\u201d to create a new repository with a simple but runnable app: github.com/square/workflow-android-template","title":"Quick Start"},{"location":"#maven-artifacts","text":"Artifacts are hosted on Maven Central. If you\u2019re using Gradle, ensure mavenCentral() appears in your repositories block, and then add dependencies on the following artifacts: Maven Coordinates Depend on this if\u2026 com.squareup.workflow:workflow-core-jvm:x.y.z You are writing a library module/project that uses Workflows, but you don't need to interact with the runtime from the outside. com.squareup.workflow:workflow-rx2:x.y.z You need to interact with RxJava2 from your Workflows. com.squareup.workflow:workflow-testing-jvm:x.y.z You are writing tests. This should only be included as a test dependency. com.squareup.workflow:workflow-ui-core-android:x.y.z You're writing an Android app that uses Workflows. com.squareup.workflow:workflow-ui-modal-android:x.y.z Your Android app uses modals (popups). com.squareup.workflow:workflow-ui-backstack-android:x.y.z Your android app uses backstacks.","title":"Maven Artifacts"},{"location":"#lower-level-artifacts","text":"Most code shouldn\u2019t need to depend on these directly. They should generally only be used to build higher-level integrations with UI frameworks. Maven Coordinates Depend on this if\u2026 com.squareup.workflow:workflow-runtime-jvm:x.y.z You need to interact directly with the runtime, i.e. streams of renderings and outputs. com.squareup.workflow:workflow-ui-core-jvm:x.y.z You are writing workflow-ui-android for another UI framework. Defines the core types used by that artifact.","title":"Lower-level Artifacts"},{"location":"#resources","text":"Square Workflow \u2013 Droidcon NYC 2019 ( slides ) SF Android GDG @ Square 2019 - Hello Workflow (live coding) Android Dialogs 5-part Coding Series 1 , 2 , 3 , 4 , 5 Reactive Workflows a Year Later \u2013 Droidcon NYC 2018 The Reactive Workflow Pattern \u2013 Fragmented Podcast The Reactive Workflow Pattern Update \u2013 Droidcon SF 2017 The Rx Workflow Pattern \u2013 Droidcon NYC 2017 ( slides )","title":"Resources"},{"location":"#support-contact","text":"Workflow maintainers hang out in the #squarelibraries channel on the Kotlin Slack and the #square-libraries-wtf channel on the Android Study Group Slack.","title":"Support &amp; Contact"},{"location":"#releasing-and-deploying","text":"See RELEASING.md .","title":"Releasing and Deploying"},{"location":"#license","text":"Copyright 2019 Square Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"CHANGELOG/","text":"","title":"Change Log \u23cf"},{"location":"CODE_OF_CONDUCT/","text":"Open Source Code of Conduct \u00b6 At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure ourcommunity continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter. Diversity Statement \u00b6 We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities. Reporting Issues \u00b6 If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below. Thanks \u00b6 Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work. Reporting Guide \u00b6 If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Code of Conduct"},{"location":"CODE_OF_CONDUCT/#open-source-code-of-conduct","text":"At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure ourcommunity continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter.","title":"Open Source Code of Conduct"},{"location":"CODE_OF_CONDUCT/#diversity-statement","text":"We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities.","title":"Diversity Statement"},{"location":"CODE_OF_CONDUCT/#reporting-issues","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below.","title":"Reporting Issues"},{"location":"CODE_OF_CONDUCT/#thanks","text":"Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work.","title":"Thanks"},{"location":"CODE_OF_CONDUCT/#reporting-guide","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Reporting Guide"},{"location":"CONTRIBUTING/","text":"Contributing \u00b6 If you would like to contribute code to Workflow you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running ./gradlew clean build . If you\u2019re using IntelliJ IDEA, we use Square\u2019s code style definitions . Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA) .","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"If you would like to contribute code to Workflow you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running ./gradlew clean build . If you\u2019re using IntelliJ IDEA, we use Square\u2019s code style definitions . Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA) .","title":"Contributing"},{"location":"RELEASING/","text":"Releasing workflow \u00b6 Production Releases \u00b6 Before you begin: Please make sure you are set up with pod trunk and your CocoaPods account is a contributor to both the Workflow and WorkflowUI pods. If you need to be added as a contributor, please open a ticket requesting access , and assign it to @bencochran or @aquageek. Merge an update of the change log with the changes since the last release. Make sure you\u2019re on the master branch (or fix branch, e.g. v0.1-fixes ). Confirm that the kotlin build is green before committing any changes 1 ( cd kotlin && ./gradlew build connectedCheck ) In kotlin/gradle.properties , remove the -SNAPSHOT prefix from the VERSION_NAME property. E.g. VERSION_NAME=0.1.0 Create a commit and tag the commit with the version number: 1 2 git commit -am \"Releasing v0.1.0.\" git tag v0.1.0 Upload the kotlin artifacts: 1 ( cd kotlin && ./gradlew clean build && ./gradlew uploadArchives --no-parallel --no-daemon ) Disabling parallelism and daemon sharing is required by the vanniktech maven publish plugin. Without those, the artifacts will be split across multiple (invalid) staging repositories. Close and release the staging repository at https://oss.sonatype.org . Publish to CocoaPods: 1 2 3 bundle exec pod trunk push Workflow.podspec bundle exec pod trunk push WorkflowTesting.podspec bundle exec pod trunk push WorkflowUI.podspec Bump the version Kotlin: Update the VERSION_NAME property in kotlin/gradle.properties to the new snapshot version, e.g. VERSION_NAME=0.2.0-SNAPSHOT . Swift: Update s.version in *.podspec to the new version, e.g. 0.2.0 . Commit the new snapshot version: 1 git commit -am \"Finish releasing v0.1.0.\" Push your commits and tag: 1 2 3 git push origin master # or git push origin fix-branch git push origin v0.1.0 Create the release on GitHub: Go to the Releases page for the GitHub project. Click \u201cDraft a new release\u201d. Enter the tag name you just pushed. Title the release with the same name as the tag. Copy & paste the changelog entry for this release into the description. If this is a pre-release version, check the pre-release box. Hit \u201cPublish release\u201d. If this was a fix release, merge changes to the master branch: 1 2 3 4 5 git checkout master git pull git merge --no-ff v0.1-fixes # Resolve conflicts. Accept master's versions of gradle.properties and podspecs. git push origin master Publish the website. See below. Deploying the documentation website \u00b6 Official Workflow documentation lives at https://squareup.github.io/workflow . The website content consists of three parts: Markdown documentation: Lives in the docs/ folder, and consists of a set of hand-written Markdown files that document high-level concepts. The static site generator mkdocs (with Material theming) is used to convert the Markdown to static, styled HTML. Kotlin API reference: Kdoc embedded in Kotlin source files is converted to GitHub-flavored Markdown by Dokka and then included in the statically-generated website. Swift API reference: Markup comments from Swift files are converted Markdown by Sourcedocs and then included in the statically-generated website. Setting up the site generators \u00b6 If you\u2019ve already done this, you can skip to Deploying the website to production below. Kotlin: Dokka \u00b6 Dokka runs as a Gradle plugin, so you need to be able to build the Kotlin source with Gradle, but that\u2019s it. To generate the docs manually, run: 1 2 cd kotlin ./gradlew dokka Swift: Sourcedocs \u00b6 Sourcedocs generates a Markdown site from Swift files. You need Ruby, rubygems, bundler (2.x), Xcode 10.2+, CocoaPods, and of course Sourcedocs itself, to run it. Assuming you\u2019ve already got Xcode, Ruby, and rubygems set up, install the rest of the dependencies: 1 2 gem install bundler cocoapods brew install sourcedocs If that succeeded, you need to generate an Xcode project before running Sourcedocs: 1 2 3 4 cd swift/Samples/SampleApp/ bundle exec pod install # If this is your first time running CocoaPods, that will fail and you'll need to run this instead: #bundle exec pod install --repo-update You can manually generate the docs to verify everything is working correctly by running: 1 2 3 4 #cd swift/Samples/SampleApp/ sourcedocs generate -- -scheme Workflow -workspace SampleApp.xcworkspace sourcedocs generate -- -scheme WorkflowUI -workspace SampleApp.xcworkspace sourcedocs generate -- -scheme WorkflowTesting -workspace SampleApp.xcworkspace Note that currently sourcedocs only supports Xcode 10, if you run it with Xcode 11 you might see an error about Catalyst and only empty READMEs will get generated. mkdocs \u00b6 Mkdocs is written in Python, so you\u2019ll need Python and pip in order to run it. Assuming those are set up, run: 1 pip install mkdocs mkdocs-material Generate the site manually with: 1 mkdocs build While you\u2019re working on the documentation files, you can run the site locally with: 1 mkdocs serve Deploying the website to production \u00b6 Before deploying the website for real, you need to export our Google Analytics key in an environment variable so that it will get added to the HTML. Get the key from one of the project maintainers, then add the following to your .bashrc and re-source it: 1 export WORKFLOW_GOOGLE_ANALYTICS_KEY = UA-__________-1 Now you\u2019re ready to publish the site! Just choose a tag or SHA to deploy from, and run: 1 2 3 ./deploy_website.sh TAG_OR_SHA # For example: #./deploy_website.sh v0.18.0 This will clone the repo to a temporary directory, checkout the right SHA, build Kotlin and Swift API docs, generate HTML, and push the newly-generated content to the gh-pages branch on GitHub. Validating Markdown \u00b6 Since all of our high-level documentation is written in Markdown, we run a linter in CI to ensure we use consistent formatting. Lint errors will fail your PR builds, so to run locally, install markdownlint : 1 gem install mdl Run the linter using the lint_docs.sh : 1 ./lint_docs.sh Rules can be configured by editing .markdownlint.rb . Kotlin Notes \u00b6 Development \u00b6 To build and install the current version to your local Maven repository ( ~/.m2 ), run: 1 ./gradlew clean installArchives Deploying \u00b6 Configuration \u00b6 In order to deploy artifacts to a Maven repository, you\u2019ll need to set 4 properties in your private Gradle properties file ( ~/.gradle/gradle.properties ): 1 2 3 4 RELEASE_REPOSITORY_URL=<url of release repository> SNAPSHOT_REPOSITORY_URL=<url of snapshot repository SONATYPE_NEXUS_USERNAME=<username> SONATYPE_NEXUS_PASSWORD=<password> Snapshot Releases \u00b6 Double-check that gradle.properties correctly contains the -SNAPSHOT suffix, then upload snapshot artifacts to Sonatype just like you would for a production release: 1 ./gradlew clean build && ./gradlew uploadArchives --no-parallel --no-daemon You can verify the artifacts are available by visiting https://oss.sonatype.org/content/repositories/snapshots/com/squareup/workflow/ .","title":"Releasing workflow"},{"location":"RELEASING/#releasing-workflow","text":"","title":"Releasing workflow"},{"location":"RELEASING/#production-releases","text":"Before you begin: Please make sure you are set up with pod trunk and your CocoaPods account is a contributor to both the Workflow and WorkflowUI pods. If you need to be added as a contributor, please open a ticket requesting access , and assign it to @bencochran or @aquageek. Merge an update of the change log with the changes since the last release. Make sure you\u2019re on the master branch (or fix branch, e.g. v0.1-fixes ). Confirm that the kotlin build is green before committing any changes 1 ( cd kotlin && ./gradlew build connectedCheck ) In kotlin/gradle.properties , remove the -SNAPSHOT prefix from the VERSION_NAME property. E.g. VERSION_NAME=0.1.0 Create a commit and tag the commit with the version number: 1 2 git commit -am \"Releasing v0.1.0.\" git tag v0.1.0 Upload the kotlin artifacts: 1 ( cd kotlin && ./gradlew clean build && ./gradlew uploadArchives --no-parallel --no-daemon ) Disabling parallelism and daemon sharing is required by the vanniktech maven publish plugin. Without those, the artifacts will be split across multiple (invalid) staging repositories. Close and release the staging repository at https://oss.sonatype.org . Publish to CocoaPods: 1 2 3 bundle exec pod trunk push Workflow.podspec bundle exec pod trunk push WorkflowTesting.podspec bundle exec pod trunk push WorkflowUI.podspec Bump the version Kotlin: Update the VERSION_NAME property in kotlin/gradle.properties to the new snapshot version, e.g. VERSION_NAME=0.2.0-SNAPSHOT . Swift: Update s.version in *.podspec to the new version, e.g. 0.2.0 . Commit the new snapshot version: 1 git commit -am \"Finish releasing v0.1.0.\" Push your commits and tag: 1 2 3 git push origin master # or git push origin fix-branch git push origin v0.1.0 Create the release on GitHub: Go to the Releases page for the GitHub project. Click \u201cDraft a new release\u201d. Enter the tag name you just pushed. Title the release with the same name as the tag. Copy & paste the changelog entry for this release into the description. If this is a pre-release version, check the pre-release box. Hit \u201cPublish release\u201d. If this was a fix release, merge changes to the master branch: 1 2 3 4 5 git checkout master git pull git merge --no-ff v0.1-fixes # Resolve conflicts. Accept master's versions of gradle.properties and podspecs. git push origin master Publish the website. See below.","title":"Production Releases"},{"location":"RELEASING/#deploying-the-documentation-website","text":"Official Workflow documentation lives at https://squareup.github.io/workflow . The website content consists of three parts: Markdown documentation: Lives in the docs/ folder, and consists of a set of hand-written Markdown files that document high-level concepts. The static site generator mkdocs (with Material theming) is used to convert the Markdown to static, styled HTML. Kotlin API reference: Kdoc embedded in Kotlin source files is converted to GitHub-flavored Markdown by Dokka and then included in the statically-generated website. Swift API reference: Markup comments from Swift files are converted Markdown by Sourcedocs and then included in the statically-generated website.","title":"Deploying the documentation website"},{"location":"RELEASING/#setting-up-the-site-generators","text":"If you\u2019ve already done this, you can skip to Deploying the website to production below.","title":"Setting up the site generators"},{"location":"RELEASING/#kotlin-dokka","text":"Dokka runs as a Gradle plugin, so you need to be able to build the Kotlin source with Gradle, but that\u2019s it. To generate the docs manually, run: 1 2 cd kotlin ./gradlew dokka","title":"Kotlin: Dokka"},{"location":"RELEASING/#swift-sourcedocs","text":"Sourcedocs generates a Markdown site from Swift files. You need Ruby, rubygems, bundler (2.x), Xcode 10.2+, CocoaPods, and of course Sourcedocs itself, to run it. Assuming you\u2019ve already got Xcode, Ruby, and rubygems set up, install the rest of the dependencies: 1 2 gem install bundler cocoapods brew install sourcedocs If that succeeded, you need to generate an Xcode project before running Sourcedocs: 1 2 3 4 cd swift/Samples/SampleApp/ bundle exec pod install # If this is your first time running CocoaPods, that will fail and you'll need to run this instead: #bundle exec pod install --repo-update You can manually generate the docs to verify everything is working correctly by running: 1 2 3 4 #cd swift/Samples/SampleApp/ sourcedocs generate -- -scheme Workflow -workspace SampleApp.xcworkspace sourcedocs generate -- -scheme WorkflowUI -workspace SampleApp.xcworkspace sourcedocs generate -- -scheme WorkflowTesting -workspace SampleApp.xcworkspace Note that currently sourcedocs only supports Xcode 10, if you run it with Xcode 11 you might see an error about Catalyst and only empty READMEs will get generated.","title":"Swift: Sourcedocs"},{"location":"RELEASING/#mkdocs","text":"Mkdocs is written in Python, so you\u2019ll need Python and pip in order to run it. Assuming those are set up, run: 1 pip install mkdocs mkdocs-material Generate the site manually with: 1 mkdocs build While you\u2019re working on the documentation files, you can run the site locally with: 1 mkdocs serve","title":"mkdocs"},{"location":"RELEASING/#deploying-the-website-to-production","text":"Before deploying the website for real, you need to export our Google Analytics key in an environment variable so that it will get added to the HTML. Get the key from one of the project maintainers, then add the following to your .bashrc and re-source it: 1 export WORKFLOW_GOOGLE_ANALYTICS_KEY = UA-__________-1 Now you\u2019re ready to publish the site! Just choose a tag or SHA to deploy from, and run: 1 2 3 ./deploy_website.sh TAG_OR_SHA # For example: #./deploy_website.sh v0.18.0 This will clone the repo to a temporary directory, checkout the right SHA, build Kotlin and Swift API docs, generate HTML, and push the newly-generated content to the gh-pages branch on GitHub.","title":"Deploying the website to production"},{"location":"RELEASING/#validating-markdown","text":"Since all of our high-level documentation is written in Markdown, we run a linter in CI to ensure we use consistent formatting. Lint errors will fail your PR builds, so to run locally, install markdownlint : 1 gem install mdl Run the linter using the lint_docs.sh : 1 ./lint_docs.sh Rules can be configured by editing .markdownlint.rb .","title":"Validating Markdown"},{"location":"RELEASING/#kotlin-notes","text":"","title":"Kotlin Notes"},{"location":"RELEASING/#development","text":"To build and install the current version to your local Maven repository ( ~/.m2 ), run: 1 ./gradlew clean installArchives","title":"Development"},{"location":"RELEASING/#deploying","text":"","title":"Deploying"},{"location":"RELEASING/#configuration","text":"In order to deploy artifacts to a Maven repository, you\u2019ll need to set 4 properties in your private Gradle properties file ( ~/.gradle/gradle.properties ): 1 2 3 4 RELEASE_REPOSITORY_URL=<url of release repository> SNAPSHOT_REPOSITORY_URL=<url of snapshot repository SONATYPE_NEXUS_USERNAME=<username> SONATYPE_NEXUS_PASSWORD=<password>","title":"Configuration"},{"location":"RELEASING/#snapshot-releases","text":"Double-check that gradle.properties correctly contains the -SNAPSHOT suffix, then upload snapshot artifacts to Sonatype just like you would for a production release: 1 ./gradlew clean build && ./gradlew uploadArchives --no-parallel --no-daemon You can verify the artifacts are available by visiting https://oss.sonatype.org/content/repositories/snapshots/com/squareup/workflow/ .","title":"Snapshot Releases"},{"location":"code-recipes/","text":"Code Receipes \u00b6 Coming soon!","title":"Code Recipes"},{"location":"code-recipes/#code-receipes","text":"Coming soon!","title":"Code Receipes"},{"location":"development-process/","text":"Development Process \u00b6 Coming soon!","title":"Development Process"},{"location":"development-process/#development-process","text":"Coming soon!","title":"Development Process"},{"location":"faq/","text":"Frequently Asked Questions \u00b6 Isn\u2019t this basically React/Elm? \u00b6 React and the Elm architecture were both strong influences for this library. However both those libraries are written for JavaScript. Workflows are written in and for both Kotlin and Swift, making use of features of those languages, and with usability from those languages as a major design goal. There are also a few architectural differences: React Elm Workflow Modularity Component TK Workflow is analogous to React\u2019s Component State Each Component has a state property that is read directly and updated via a setState method. State is called Model in Elm. Workflow s have an associated state type. The state can only be updated when the props change, or with a WorkflowAction . Views Component s have a render method that returns a tree of elements. Elm applications have a view function that returns a tree of elements. Since workflows are not tied to any particular UI view layer, they can have an arbitrary rendering type. The render() method returns this type. Dependencies React allows parent components to pass \u201cprops\u201d down to their children. TK In Swift, Workflow s are often structs that need to be initialized with their dependencies and configuration data from their parent. In Kotlin, they have a separate type parameter ( PropsT ) that is always passed down from the parent. Workflow instances can also inject dependencies, and play nicely with dependency injection frameworks. Composability TK TK TK Event Handling TK TK TK How is this different than MvRx? \u00b6 Besides being very Android and Rx specific, MvRx solves view modeling problems only per screen. Workflow was mainly inspired by the need to manage and compose navigation in apps with dozens or hundreds of screens. How do I get involved and/or contribute? \u00b6 Workflow is open source! See our CONTRIBUTING doc to get started. Stay tuned! We\u2019re considering hosting a public Slack channel for open source contributors. This seems clever. Can I stick with a traditional development approach? \u00b6 Of course! Workflow was designed to make complex application architecture predictable and safe for large development teams. We\u2019re confident that it brings benefits even to smaller projects, but there is never only one right way to build software. We recommend to follow good practices and use an architecture that makes sense for your project . Why do we need another architecture? \u00b6 Architectural patterns with weak access controls and heavy use of shared mutable state make it incredibly difficult to fully understand the behavior of the code that we are writing. This quickly devolves into an arms race as the codebase grows: if every feature or component in the codebase might change anything at any time, bug fixes turn into a really sad game of whack-a-mole. We have seen this pattern occur repeatedly in traditional mobile applications using patterns like MVC. Workflow defines strong boundaries and contracts between separate parts of the application to ensure that our code remains predictable and maintainable as the size and complexity of the codebase grows.","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"faq/#isnt-this-basically-reactelm","text":"React and the Elm architecture were both strong influences for this library. However both those libraries are written for JavaScript. Workflows are written in and for both Kotlin and Swift, making use of features of those languages, and with usability from those languages as a major design goal. There are also a few architectural differences: React Elm Workflow Modularity Component TK Workflow is analogous to React\u2019s Component State Each Component has a state property that is read directly and updated via a setState method. State is called Model in Elm. Workflow s have an associated state type. The state can only be updated when the props change, or with a WorkflowAction . Views Component s have a render method that returns a tree of elements. Elm applications have a view function that returns a tree of elements. Since workflows are not tied to any particular UI view layer, they can have an arbitrary rendering type. The render() method returns this type. Dependencies React allows parent components to pass \u201cprops\u201d down to their children. TK In Swift, Workflow s are often structs that need to be initialized with their dependencies and configuration data from their parent. In Kotlin, they have a separate type parameter ( PropsT ) that is always passed down from the parent. Workflow instances can also inject dependencies, and play nicely with dependency injection frameworks. Composability TK TK TK Event Handling TK TK TK","title":"Isn't this basically React/Elm?"},{"location":"faq/#how-is-this-different-than-mvrx","text":"Besides being very Android and Rx specific, MvRx solves view modeling problems only per screen. Workflow was mainly inspired by the need to manage and compose navigation in apps with dozens or hundreds of screens.","title":"How is this different than MvRx?"},{"location":"faq/#how-do-i-get-involved-andor-contribute","text":"Workflow is open source! See our CONTRIBUTING doc to get started. Stay tuned! We\u2019re considering hosting a public Slack channel for open source contributors.","title":"How do I get involved and/or contribute?"},{"location":"faq/#this-seems-clever-can-i-stick-with-a-traditional-development-approach","text":"Of course! Workflow was designed to make complex application architecture predictable and safe for large development teams. We\u2019re confident that it brings benefits even to smaller projects, but there is never only one right way to build software. We recommend to follow good practices and use an architecture that makes sense for your project .","title":"This seems clever. Can I stick with a traditional development approach?"},{"location":"faq/#why-do-we-need-another-architecture","text":"Architectural patterns with weak access controls and heavy use of shared mutable state make it incredibly difficult to fully understand the behavior of the code that we are writing. This quickly devolves into an arms race as the codebase grows: if every feature or component in the codebase might change anything at any time, bug fixes turn into a really sad game of whack-a-mole. We have seen this pattern occur repeatedly in traditional mobile applications using patterns like MVC. Workflow defines strong boundaries and contracts between separate parts of the application to ensure that our code remains predictable and maintainable as the size and complexity of the codebase grows.","title":"Why do we need another architecture?"},{"location":"swift/api/Workflow/","text":"Protocols \u00b6 AnyWorkflowConvertible Worker Workflow WorkflowAction WorkflowDebugger Structs \u00b6 AnyWorkflow AnyWorkflowAction Child Sink WorkflowHierarchyDebugSnapshot WorkflowUpdateDebugInfo Classes \u00b6 RenderContext WorkflowHost Enums \u00b6 Kind Source Extensions \u00b6 AnyWorkflow AnyWorkflowAction AnyWorkflowConvertible RenderContext Worker Workflow WorkflowUpdateDebugInfo.Kind WorkflowUpdateDebugInfo.Source Reference Documentation \u00b6 This reference documentation was generated with SourceDocs .","title":"Workflow "},{"location":"swift/api/Workflow/#protocols","text":"AnyWorkflowConvertible Worker Workflow WorkflowAction WorkflowDebugger","title":"Protocols"},{"location":"swift/api/Workflow/#structs","text":"AnyWorkflow AnyWorkflowAction Child Sink WorkflowHierarchyDebugSnapshot WorkflowUpdateDebugInfo","title":"Structs"},{"location":"swift/api/Workflow/#classes","text":"RenderContext WorkflowHost","title":"Classes"},{"location":"swift/api/Workflow/#enums","text":"Kind Source","title":"Enums"},{"location":"swift/api/Workflow/#extensions","text":"AnyWorkflow AnyWorkflowAction AnyWorkflowConvertible RenderContext Worker Workflow WorkflowUpdateDebugInfo.Kind WorkflowUpdateDebugInfo.Source","title":"Extensions"},{"location":"swift/api/Workflow/#reference-documentation","text":"This reference documentation was generated with SourceDocs .","title":"Reference Documentation"},{"location":"swift/api/Workflow/classes/RenderContext/","text":"CLASS RenderContext \u00b6 1 public class RenderContext < WorkflowType : Workflow >: RenderContextType RenderContext is the composition point for the workflow tree. During a render pass, a workflow may want to defer to a child workflow to render some portion of its content. For example, a workflow that renders to a split-screen view model might delegate to child A for the left side, and child B for the right side view models. Nesting allows for a fractal tree that is constructed out of many small parts. If a parent wants to delegate to a child workflow, it must first create an instance of that workflow. This can be thought of as the model of the child workflow. It does not contain any active state, it simply contains the data necessary to create or update a workflow node. The parent then calls render(workflow:outputMap:) with two values: - The child workflow. - A closure that transforms the child\u2019s output events into the parent\u2019s Event type so that the parent can respond to events generated by the child. If the parent had previously rendered a child of the same type, the existing child workflow node is updated. If the parent had not rendered a child of the same type in the previous render pass, a new child workflow node is generated. The infrastructure then performs a render pass on the child to obtain its Rendering value, which is then returned to the caller. Methods \u00b6 render(workflow:key:outputMap:) \u00b6 1 public func render < Child , Action >( workflow : Child , key : String , outputMap : @ escaping ( Child . Output ) -> Action ) -> Child . Rendering where Child : Workflow , Action : WorkflowAction , WorkflowType == Action . WorkflowType Creates or updates a child workflow of the given type, performs a render pass, and returns the result. Note that it is a programmer error to render two instances of a given workflow type with the same key during the same render pass. Parameter workflow: The child workflow to be rendered. Parameter outputMap: A closure that transforms the child\u2019s output type into Action . Parameter key: A string that uniquely identifies this child. Returns: The Rendering result of the child\u2019s render method. Parameters \u00b6 Name Description workflow The child workflow to be rendered. outputMap A closure that transforms the child\u2019s output type into Action . key A string that uniquely identifies this child. makeSink(of:) \u00b6 1 public func makeSink < Action >( of actionType : Action . Type ) -> Sink < Action > where Action : WorkflowAction , Action . WorkflowType == WorkflowType subscribe(signal:) \u00b6 1 public func subscribe < Action >( signal : Signal < Action , Never >) where Action : WorkflowAction , WorkflowType == Action . WorkflowType awaitResult(for:outputMap:) \u00b6 1 public func awaitResult < W , Action >( for worker : W , outputMap : @ escaping ( W . Output ) -> Action ) where W : Worker , Action : WorkflowAction , WorkflowType == Action . WorkflowType","title":"RenderContext"},{"location":"swift/api/Workflow/classes/RenderContext/#rendercontext","text":"1 public class RenderContext < WorkflowType : Workflow >: RenderContextType RenderContext is the composition point for the workflow tree. During a render pass, a workflow may want to defer to a child workflow to render some portion of its content. For example, a workflow that renders to a split-screen view model might delegate to child A for the left side, and child B for the right side view models. Nesting allows for a fractal tree that is constructed out of many small parts. If a parent wants to delegate to a child workflow, it must first create an instance of that workflow. This can be thought of as the model of the child workflow. It does not contain any active state, it simply contains the data necessary to create or update a workflow node. The parent then calls render(workflow:outputMap:) with two values: - The child workflow. - A closure that transforms the child\u2019s output events into the parent\u2019s Event type so that the parent can respond to events generated by the child. If the parent had previously rendered a child of the same type, the existing child workflow node is updated. If the parent had not rendered a child of the same type in the previous render pass, a new child workflow node is generated. The infrastructure then performs a render pass on the child to obtain its Rendering value, which is then returned to the caller.","title":"RenderContext"},{"location":"swift/api/Workflow/classes/RenderContext/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/classes/RenderContext/#renderworkflowkeyoutputmap","text":"1 public func render < Child , Action >( workflow : Child , key : String , outputMap : @ escaping ( Child . Output ) -> Action ) -> Child . Rendering where Child : Workflow , Action : WorkflowAction , WorkflowType == Action . WorkflowType Creates or updates a child workflow of the given type, performs a render pass, and returns the result. Note that it is a programmer error to render two instances of a given workflow type with the same key during the same render pass. Parameter workflow: The child workflow to be rendered. Parameter outputMap: A closure that transforms the child\u2019s output type into Action . Parameter key: A string that uniquely identifies this child. Returns: The Rendering result of the child\u2019s render method.","title":"render(workflow:key:outputMap:)"},{"location":"swift/api/Workflow/classes/RenderContext/#parameters","text":"Name Description workflow The child workflow to be rendered. outputMap A closure that transforms the child\u2019s output type into Action . key A string that uniquely identifies this child.","title":"Parameters"},{"location":"swift/api/Workflow/classes/RenderContext/#makesinkof","text":"1 public func makeSink < Action >( of actionType : Action . Type ) -> Sink < Action > where Action : WorkflowAction , Action . WorkflowType == WorkflowType","title":"makeSink(of:)"},{"location":"swift/api/Workflow/classes/RenderContext/#subscribesignal","text":"1 public func subscribe < Action >( signal : Signal < Action , Never >) where Action : WorkflowAction , WorkflowType == Action . WorkflowType","title":"subscribe(signal:)"},{"location":"swift/api/Workflow/classes/RenderContext/#awaitresultforoutputmap","text":"1 public func awaitResult < W , Action >( for worker : W , outputMap : @ escaping ( W . Output ) -> Action ) where W : Worker , Action : WorkflowAction , WorkflowType == Action . WorkflowType","title":"awaitResult(for:outputMap:)"},{"location":"swift/api/Workflow/classes/WorkflowHost/","text":"CLASS WorkflowHost \u00b6 1 public final class WorkflowHost < WorkflowType : Workflow > Manages an active workflow hierarchy. Properties \u00b6 rendering \u00b6 1 public let rendering : Property < WorkflowType . Rendering > Represents the Rendering produced by the root workflow in the hierarchy. New Rendering values are produced as state transitions occur within the hierarchy. output \u00b6 1 public var output : Signal < WorkflowType . Output , Never > A signal containing output events emitted by the root workflow in the hierarchy. Methods \u00b6 init(workflow:debugger:) \u00b6 1 public init ( workflow : WorkflowType , debugger : WorkflowDebugger ? = nil ) Initializes a new host with the given workflow at the root. Parameter workflow: The root workflow in the hierarchy Parameter debugger: An optional debugger. If provided, the host will notify the debugger of updates to the workflow hierarchy as state transitions occur. Parameters \u00b6 Name Description workflow The root workflow in the hierarchy debugger An optional debugger. If provided, the host will notify the debugger of updates to the workflow hierarchy as state transitions occur. update(workflow:) \u00b6 1 public func update ( workflow : WorkflowType ) Update the input for the workflow. Will cause a render pass.","title":"WorkflowHost"},{"location":"swift/api/Workflow/classes/WorkflowHost/#workflowhost","text":"1 public final class WorkflowHost < WorkflowType : Workflow > Manages an active workflow hierarchy.","title":"WorkflowHost"},{"location":"swift/api/Workflow/classes/WorkflowHost/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/classes/WorkflowHost/#rendering","text":"1 public let rendering : Property < WorkflowType . Rendering > Represents the Rendering produced by the root workflow in the hierarchy. New Rendering values are produced as state transitions occur within the hierarchy.","title":"rendering"},{"location":"swift/api/Workflow/classes/WorkflowHost/#output","text":"1 public var output : Signal < WorkflowType . Output , Never > A signal containing output events emitted by the root workflow in the hierarchy.","title":"output"},{"location":"swift/api/Workflow/classes/WorkflowHost/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/classes/WorkflowHost/#initworkflowdebugger","text":"1 public init ( workflow : WorkflowType , debugger : WorkflowDebugger ? = nil ) Initializes a new host with the given workflow at the root. Parameter workflow: The root workflow in the hierarchy Parameter debugger: An optional debugger. If provided, the host will notify the debugger of updates to the workflow hierarchy as state transitions occur.","title":"init(workflow:debugger:)"},{"location":"swift/api/Workflow/classes/WorkflowHost/#parameters","text":"Name Description workflow The root workflow in the hierarchy debugger An optional debugger. If provided, the host will notify the debugger of updates to the workflow hierarchy as state transitions occur.","title":"Parameters"},{"location":"swift/api/Workflow/classes/WorkflowHost/#updateworkflow","text":"1 public func update ( workflow : WorkflowType ) Update the input for the workflow. Will cause a render pass.","title":"update(workflow:)"},{"location":"swift/api/Workflow/enums/Kind/","text":"ENUM Kind \u00b6 1 public indirect enum Kind : Equatable Cases \u00b6 didUpdate(source:) \u00b6 1 case didUpdate ( source : Source ) childDidUpdate(_:) \u00b6 1 case childDidUpdate ( WorkflowUpdateDebugInfo )","title":"Kind"},{"location":"swift/api/Workflow/enums/Kind/#kind","text":"1 public indirect enum Kind : Equatable","title":"Kind"},{"location":"swift/api/Workflow/enums/Kind/#cases","text":"","title":"Cases"},{"location":"swift/api/Workflow/enums/Kind/#didupdatesource","text":"1 case didUpdate ( source : Source )","title":"didUpdate(source:)"},{"location":"swift/api/Workflow/enums/Kind/#childdidupdate_","text":"1 case childDidUpdate ( WorkflowUpdateDebugInfo )","title":"childDidUpdate(_:)"},{"location":"swift/api/Workflow/enums/Source/","text":"ENUM Source \u00b6 1 public indirect enum Source : Equatable Cases \u00b6 external \u00b6 1 case external worker \u00b6 1 case worker subtree(_:) \u00b6 1 case subtree ( WorkflowUpdateDebugInfo )","title":"Source"},{"location":"swift/api/Workflow/enums/Source/#source","text":"1 public indirect enum Source : Equatable","title":"Source"},{"location":"swift/api/Workflow/enums/Source/#cases","text":"","title":"Cases"},{"location":"swift/api/Workflow/enums/Source/#external","text":"1 case external","title":"external"},{"location":"swift/api/Workflow/enums/Source/#worker","text":"1 case worker","title":"worker"},{"location":"swift/api/Workflow/enums/Source/#subtree_","text":"1 case subtree ( WorkflowUpdateDebugInfo )","title":"subtree(_:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/","text":"EXTENSION AnyWorkflow \u00b6 Methods \u00b6 asAnyWorkflow() \u00b6 1 public func asAnyWorkflow () -> AnyWorkflow < Rendering , Output > mapOutput(_:) \u00b6 1 public func mapOutput < NewOutput >( _ transform : @ escaping ( Output ) -> NewOutput ) -> AnyWorkflow < Rendering , NewOutput > Returns a new AnyWorkflow whose Output type has been transformed into the given type. Parameter transform: An escaping closure that maps the original output type into the new output type. Returns: A type erased workflow with the new output type (the rendering type remains unchanged). Parameters \u00b6 Name Description transform An escaping closure that maps the original output type into the new output type. mapRendering(_:) \u00b6 1 public func mapRendering < NewRendering >( _ transform : @ escaping ( Rendering ) -> NewRendering ) -> AnyWorkflow < NewRendering , Output > Returns a new AnyWorkflow whose Rendering type has been transformed into the given type. Parameter transform: An escaping closure that maps the original rendering type into the new rendering type. Returns: A type erased workflow with the new rendering type (the output type remains unchanged). Parameters \u00b6 Name Description transform An escaping closure that maps the original rendering type into the new rendering type.","title":"AnyWorkflow"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/#anyworkflow","text":"","title":"AnyWorkflow"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/#asanyworkflow","text":"1 public func asAnyWorkflow () -> AnyWorkflow < Rendering , Output >","title":"asAnyWorkflow()"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/#mapoutput_","text":"1 public func mapOutput < NewOutput >( _ transform : @ escaping ( Output ) -> NewOutput ) -> AnyWorkflow < Rendering , NewOutput > Returns a new AnyWorkflow whose Output type has been transformed into the given type. Parameter transform: An escaping closure that maps the original output type into the new output type. Returns: A type erased workflow with the new output type (the rendering type remains unchanged).","title":"mapOutput(_:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/#parameters","text":"Name Description transform An escaping closure that maps the original output type into the new output type.","title":"Parameters"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/#maprendering_","text":"1 public func mapRendering < NewRendering >( _ transform : @ escaping ( Rendering ) -> NewRendering ) -> AnyWorkflow < NewRendering , Output > Returns a new AnyWorkflow whose Rendering type has been transformed into the given type. Parameter transform: An escaping closure that maps the original rendering type into the new rendering type. Returns: A type erased workflow with the new rendering type (the output type remains unchanged).","title":"mapRendering(_:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflow/#parameters_1","text":"Name Description transform An escaping closure that maps the original rendering type into the new rendering type.","title":"Parameters"},{"location":"swift/api/Workflow/extensions/AnyWorkflowAction/","text":"EXTENSION AnyWorkflowAction \u00b6 Methods \u00b6 init(sendingOutput:) \u00b6 1 public init ( sendingOutput output : WorkflowType . Output ) Creates a type-erased workflow action that simply sends the given output event. Parameter output: The output event to send when this action is applied. Parameters \u00b6 Name Description output The output event to send when this action is applied.","title":"AnyWorkflowAction"},{"location":"swift/api/Workflow/extensions/AnyWorkflowAction/#anyworkflowaction","text":"","title":"AnyWorkflowAction"},{"location":"swift/api/Workflow/extensions/AnyWorkflowAction/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/AnyWorkflowAction/#initsendingoutput","text":"1 public init ( sendingOutput output : WorkflowType . Output ) Creates a type-erased workflow action that simply sends the given output event. Parameter output: The output event to send when this action is applied.","title":"init(sendingOutput:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowAction/#parameters","text":"Name Description output The output event to send when this action is applied.","title":"Parameters"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/","text":"EXTENSION AnyWorkflowConvertible \u00b6 Methods \u00b6 mapOutput(_:) \u00b6 1 public func mapOutput < NewOutput >( _ transform : @ escaping ( Output ) -> NewOutput ) -> AnyWorkflow < Rendering , NewOutput > mapRendering(_:) \u00b6 1 public func mapRendering < NewRendering >( _ transform : @ escaping ( Rendering ) -> NewRendering ) -> AnyWorkflow < NewRendering , Output > rendered(with:key:) \u00b6 1 public func rendered < Parent >( with context : RenderContext < Parent >, key : String = \"\" ) -> Rendering where Output : WorkflowAction , Output . WorkflowType == Parent Creates or updates a child workflow of the given type, performs a render pass, and returns the result. Note that it is a programmer error to render two instances of a given workflow type with the same key during the same render pass. Parameter context: The context with which the workflow will be rendered. Parameter key: A string that uniquely identifies this workflow. Returns: The Rendering generated by the workflow. Parameters \u00b6 Name Description context The context with which the workflow will be rendered. key A string that uniquely identifies this workflow. rendered(with:key:) \u00b6 1 public func rendered < Parent >( with context : RenderContext < Parent >, key : String = \"\" ) -> Rendering where Output == AnyWorkflowAction < Parent > rendered(with:key:) \u00b6 1 public func rendered < T >( with context : RenderContext < T >, key : String = \"\" ) -> Rendering Creates or updates a child workflow of the given type, performs a render pass, and returns the result. Note that it is a programmer error to render two instances of a given workflow type with the same key during the same render pass. Parameter context: The context with which the workflow will be rendered. Parameter key: A string that uniquely identifies this workflow. Returns: The Rendering generated by the workflow. Parameters \u00b6 Name Description context The context with which the workflow will be rendered. key A string that uniquely identifies this workflow.","title":"AnyWorkflowConvertible"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#anyworkflowconvertible","text":"","title":"AnyWorkflowConvertible"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#mapoutput_","text":"1 public func mapOutput < NewOutput >( _ transform : @ escaping ( Output ) -> NewOutput ) -> AnyWorkflow < Rendering , NewOutput >","title":"mapOutput(_:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#maprendering_","text":"1 public func mapRendering < NewRendering >( _ transform : @ escaping ( Rendering ) -> NewRendering ) -> AnyWorkflow < NewRendering , Output >","title":"mapRendering(_:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#renderedwithkey","text":"1 public func rendered < Parent >( with context : RenderContext < Parent >, key : String = \"\" ) -> Rendering where Output : WorkflowAction , Output . WorkflowType == Parent Creates or updates a child workflow of the given type, performs a render pass, and returns the result. Note that it is a programmer error to render two instances of a given workflow type with the same key during the same render pass. Parameter context: The context with which the workflow will be rendered. Parameter key: A string that uniquely identifies this workflow. Returns: The Rendering generated by the workflow.","title":"rendered(with:key:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#parameters","text":"Name Description context The context with which the workflow will be rendered. key A string that uniquely identifies this workflow.","title":"Parameters"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#renderedwithkey_1","text":"1 public func rendered < Parent >( with context : RenderContext < Parent >, key : String = \"\" ) -> Rendering where Output == AnyWorkflowAction < Parent >","title":"rendered(with:key:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#renderedwithkey_2","text":"1 public func rendered < T >( with context : RenderContext < T >, key : String = \"\" ) -> Rendering Creates or updates a child workflow of the given type, performs a render pass, and returns the result. Note that it is a programmer error to render two instances of a given workflow type with the same key during the same render pass. Parameter context: The context with which the workflow will be rendered. Parameter key: A string that uniquely identifies this workflow. Returns: The Rendering generated by the workflow.","title":"rendered(with:key:)"},{"location":"swift/api/Workflow/extensions/AnyWorkflowConvertible/#parameters_1","text":"Name Description context The context with which the workflow will be rendered. key A string that uniquely identifies this workflow.","title":"Parameters"},{"location":"swift/api/Workflow/extensions/RenderContext/","text":"EXTENSION RenderContext \u00b6 Methods \u00b6 makeSink(of:onEvent:) \u00b6 1 public func makeSink < Event >( of eventType : Event . Type , onEvent : @ escaping ( Event , inout WorkflowType . State ) -> WorkflowType . Output ?) -> Sink < Event > awaitResult(for:) \u00b6 1 public func awaitResult < W >( for worker : W ) where W : Worker , W . Output : WorkflowAction , WorkflowType == W . Output . WorkflowType awaitResult(for:onOutput:) \u00b6 1 public func awaitResult < W >( for worker : W , onOutput : @ escaping ( W . Output , inout WorkflowType . State ) -> WorkflowType . Output ?) where W : Worker","title":"RenderContext"},{"location":"swift/api/Workflow/extensions/RenderContext/#rendercontext","text":"","title":"RenderContext"},{"location":"swift/api/Workflow/extensions/RenderContext/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/RenderContext/#makesinkofonevent","text":"1 public func makeSink < Event >( of eventType : Event . Type , onEvent : @ escaping ( Event , inout WorkflowType . State ) -> WorkflowType . Output ?) -> Sink < Event >","title":"makeSink(of:onEvent:)"},{"location":"swift/api/Workflow/extensions/RenderContext/#awaitresultfor","text":"1 public func awaitResult < W >( for worker : W ) where W : Worker , W . Output : WorkflowAction , WorkflowType == W . Output . WorkflowType","title":"awaitResult(for:)"},{"location":"swift/api/Workflow/extensions/RenderContext/#awaitresultforonoutput","text":"1 public func awaitResult < W >( for worker : W , onOutput : @ escaping ( W . Output , inout WorkflowType . State ) -> WorkflowType . Output ?) where W : Worker","title":"awaitResult(for:onOutput:)"},{"location":"swift/api/Workflow/extensions/Worker/","text":"EXTENSION Worker \u00b6 Methods \u00b6 isEquivalent(to:) \u00b6 1 public func isEquivalent ( to otherWorker : Self ) -> Bool","title":"Worker"},{"location":"swift/api/Workflow/extensions/Worker/#worker","text":"","title":"Worker"},{"location":"swift/api/Workflow/extensions/Worker/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/Worker/#isequivalentto","text":"1 public func isEquivalent ( to otherWorker : Self ) -> Bool","title":"isEquivalent(to:)"},{"location":"swift/api/Workflow/extensions/Workflow/","text":"EXTENSION Workflow \u00b6 Methods \u00b6 asAnyWorkflow() \u00b6 1 public func asAnyWorkflow () -> AnyWorkflow < Rendering , Output >","title":"Workflow"},{"location":"swift/api/Workflow/extensions/Workflow/#workflow","text":"","title":"Workflow"},{"location":"swift/api/Workflow/extensions/Workflow/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/Workflow/#asanyworkflow","text":"1 public func asAnyWorkflow () -> AnyWorkflow < Rendering , Output >","title":"asAnyWorkflow()"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Kind/","text":"EXTENSION WorkflowUpdateDebugInfo.Kind \u00b6 Methods \u00b6 encode(to:) \u00b6 1 public func encode ( to encoder : Encoder ) throws Parameters \u00b6 Name Description encoder The encoder to write data to. init(from:) \u00b6 1 public init ( from decoder : Decoder ) throws Parameters \u00b6 Name Description decoder The decoder to read data from.","title":"WorkflowUpdateDebugInfo.Kind"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Kind/#workflowupdatedebuginfokind","text":"","title":"WorkflowUpdateDebugInfo.Kind"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Kind/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Kind/#encodeto","text":"1 public func encode ( to encoder : Encoder ) throws","title":"encode(to:)"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Kind/#parameters","text":"Name Description encoder The encoder to write data to.","title":"Parameters"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Kind/#initfrom","text":"1 public init ( from decoder : Decoder ) throws","title":"init(from:)"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Kind/#parameters_1","text":"Name Description decoder The decoder to read data from.","title":"Parameters"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Source/","text":"EXTENSION WorkflowUpdateDebugInfo.Source \u00b6 Methods \u00b6 encode(to:) \u00b6 1 public func encode ( to encoder : Encoder ) throws Parameters \u00b6 Name Description encoder The encoder to write data to. init(from:) \u00b6 1 public init ( from decoder : Decoder ) throws Parameters \u00b6 Name Description decoder The decoder to read data from.","title":"WorkflowUpdateDebugInfo.Source"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Source/#workflowupdatedebuginfosource","text":"","title":"WorkflowUpdateDebugInfo.Source"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Source/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Source/#encodeto","text":"1 public func encode ( to encoder : Encoder ) throws","title":"encode(to:)"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Source/#parameters","text":"Name Description encoder The encoder to write data to.","title":"Parameters"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Source/#initfrom","text":"1 public init ( from decoder : Decoder ) throws","title":"init(from:)"},{"location":"swift/api/Workflow/extensions/WorkflowUpdateDebugInfo.Source/#parameters_1","text":"Name Description decoder The decoder to read data from.","title":"Parameters"},{"location":"swift/api/Workflow/protocols/AnyWorkflowConvertible/","text":"PROTOCOL AnyWorkflowConvertible \u00b6 1 public protocol AnyWorkflowConvertible Conforming types can be converted into AnyWorkflow values, allowing them to participate in a workflow hierarchy. Methods \u00b6 asAnyWorkflow() \u00b6 1 func asAnyWorkflow () -> AnyWorkflow < Rendering , Output > Returns an AnyWorkflow representing this value.","title":"AnyWorkflowConvertible"},{"location":"swift/api/Workflow/protocols/AnyWorkflowConvertible/#anyworkflowconvertible","text":"1 public protocol AnyWorkflowConvertible Conforming types can be converted into AnyWorkflow values, allowing them to participate in a workflow hierarchy.","title":"AnyWorkflowConvertible"},{"location":"swift/api/Workflow/protocols/AnyWorkflowConvertible/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/protocols/AnyWorkflowConvertible/#asanyworkflow","text":"1 func asAnyWorkflow () -> AnyWorkflow < Rendering , Output > Returns an AnyWorkflow representing this value.","title":"asAnyWorkflow()"},{"location":"swift/api/Workflow/protocols/Worker/","text":"PROTOCOL Worker \u00b6 1 public protocol Worker Workers define a unit of asynchronous work. During a render pass, a workflow can ask the context to await the result of a worker. When this occurs, the context checks to see if there is already a running worker of the same type. If there is, and if the workers are \u2018equivalent\u2019, the context leaves the existing worker running. If there is not an existing worker of this type, the context will kick off the new worker (via run ). Methods \u00b6 run() \u00b6 1 func run () -> SignalProducer < Output , Never > Returns a signal producer to execute the work represented by this worker. isEquivalent(to:) \u00b6 1 func isEquivalent ( to otherWorker : Self ) -> Bool Returns true if the other worker should be considered equivalent to self . Equivalence should take into account whatever data is meaninful to the task. For example, a worker that loads a user account from a server would not be equivalent to another worker with a different user ID.","title":"Worker"},{"location":"swift/api/Workflow/protocols/Worker/#worker","text":"1 public protocol Worker Workers define a unit of asynchronous work. During a render pass, a workflow can ask the context to await the result of a worker. When this occurs, the context checks to see if there is already a running worker of the same type. If there is, and if the workers are \u2018equivalent\u2019, the context leaves the existing worker running. If there is not an existing worker of this type, the context will kick off the new worker (via run ).","title":"Worker"},{"location":"swift/api/Workflow/protocols/Worker/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/protocols/Worker/#run","text":"1 func run () -> SignalProducer < Output , Never > Returns a signal producer to execute the work represented by this worker.","title":"run()"},{"location":"swift/api/Workflow/protocols/Worker/#isequivalentto","text":"1 func isEquivalent ( to otherWorker : Self ) -> Bool Returns true if the other worker should be considered equivalent to self . Equivalence should take into account whatever data is meaninful to the task. For example, a worker that loads a user account from a server would not be equivalent to another worker with a different user ID.","title":"isEquivalent(to:)"},{"location":"swift/api/Workflow/protocols/Workflow/","text":"PROTOCOL Workflow \u00b6 1 public protocol Workflow : AnyWorkflowConvertible Defines a node in the workflow tree. Initialization and Updating A workflow node comes into existence after its parent produces an instance of that workflow and uses it during a render pass (see the render method for more details). If this is the first time the parent has rendered a child of this type, a new workflow node is created. The workflow passed in from the parent will be used to invoke initialState() to obtain an initial state. If the parent had previously rendered a child of this type, the existing workflow node will be updated. workflowDidChange(from:state:) will be invoked to allow the workflow to respond to the change. Render After a workflow node has been created, or any time its state changes, a render pass occurs. The render pass takes the workflow that was passed down from the parent along with the current state and generates a value of type Rendering . In a common case, a workflow might render to a screen model for display. 1 2 3 func render(state: State, context: RenderContext<Self>) -> MyScreenModel { return MyScreenModel() } Methods \u00b6 makeInitialState() \u00b6 1 func makeInitialState () -> State This method is invoked once when a workflow node comes into existence. Returns: The initial state for the workflow. workflowDidChange(from:state:) \u00b6 1 func workflowDidChange ( from previousWorkflow : Self , state : inout State ) Called when a new workflow is passed down from the parent to an existing workflow node. Parameter previousWorkflow: The workflow before the update. Parameter state: The current state. Parameters \u00b6 Name Description previousWorkflow The workflow before the update. state The current state. render(state:context:) \u00b6 1 func render ( state : State , context : RenderContext < Self >) -> Rendering Called to \u201crender\u201d the current state into Rendering . A workflow\u2019s Rendering type is commonly a view or screen model. Parameter state: The current state. Parameter context: The workflow context is the composition point for the workflow tree. To use a nested workflow, instantiate it based on the current state. The newly instantiated workflow is then used to invoke context.render(_ workflow:) , which returns the child\u2019s Rendering type after creating or updating the nested workflow. Parameters \u00b6 Name Description state The current state. context The workflow context is the composition point for the workflow tree. To use a nested workflow, instantiate it based on the current state. The newly instantiated workflow is then used to invoke context.render(_ workflow:) , which returns the child\u2019s Rendering type after creating or updating the nested workflow.","title":"Workflow"},{"location":"swift/api/Workflow/protocols/Workflow/#workflow","text":"1 public protocol Workflow : AnyWorkflowConvertible Defines a node in the workflow tree. Initialization and Updating A workflow node comes into existence after its parent produces an instance of that workflow and uses it during a render pass (see the render method for more details). If this is the first time the parent has rendered a child of this type, a new workflow node is created. The workflow passed in from the parent will be used to invoke initialState() to obtain an initial state. If the parent had previously rendered a child of this type, the existing workflow node will be updated. workflowDidChange(from:state:) will be invoked to allow the workflow to respond to the change. Render After a workflow node has been created, or any time its state changes, a render pass occurs. The render pass takes the workflow that was passed down from the parent along with the current state and generates a value of type Rendering . In a common case, a workflow might render to a screen model for display. 1 2 3 func render(state: State, context: RenderContext<Self>) -> MyScreenModel { return MyScreenModel() }","title":"Workflow"},{"location":"swift/api/Workflow/protocols/Workflow/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/protocols/Workflow/#makeinitialstate","text":"1 func makeInitialState () -> State This method is invoked once when a workflow node comes into existence. Returns: The initial state for the workflow.","title":"makeInitialState()"},{"location":"swift/api/Workflow/protocols/Workflow/#workflowdidchangefromstate","text":"1 func workflowDidChange ( from previousWorkflow : Self , state : inout State ) Called when a new workflow is passed down from the parent to an existing workflow node. Parameter previousWorkflow: The workflow before the update. Parameter state: The current state.","title":"workflowDidChange(from:state:)"},{"location":"swift/api/Workflow/protocols/Workflow/#parameters","text":"Name Description previousWorkflow The workflow before the update. state The current state.","title":"Parameters"},{"location":"swift/api/Workflow/protocols/Workflow/#renderstatecontext","text":"1 func render ( state : State , context : RenderContext < Self >) -> Rendering Called to \u201crender\u201d the current state into Rendering . A workflow\u2019s Rendering type is commonly a view or screen model. Parameter state: The current state. Parameter context: The workflow context is the composition point for the workflow tree. To use a nested workflow, instantiate it based on the current state. The newly instantiated workflow is then used to invoke context.render(_ workflow:) , which returns the child\u2019s Rendering type after creating or updating the nested workflow.","title":"render(state:context:)"},{"location":"swift/api/Workflow/protocols/Workflow/#parameters_1","text":"Name Description state The current state. context The workflow context is the composition point for the workflow tree. To use a nested workflow, instantiate it based on the current state. The newly instantiated workflow is then used to invoke context.render(_ workflow:) , which returns the child\u2019s Rendering type after creating or updating the nested workflow.","title":"Parameters"},{"location":"swift/api/Workflow/protocols/WorkflowAction/","text":"PROTOCOL WorkflowAction \u00b6 1 public protocol WorkflowAction Conforming types represent an action that advances a workflow. When applied, an action emits the next state and / or output for the workflow. Methods \u00b6 apply(toState:) \u00b6 1 func apply ( toState state : inout WorkflowType . State ) -> WorkflowType . Output ? Applies this action to a given state of the workflow, optionally returning an output event. Parameter state: The current state of the workflow. The state is passed as an inout param, allowing actions to modify state during application. Returns: An optional output event for the workflow. If an output event is returned, it will be passed up the workflow hierarchy to this workflow\u2019s parent. Parameters \u00b6 Name Description state The current state of the workflow. The state is passed as an inout param, allowing actions to modify state during application.","title":"WorkflowAction"},{"location":"swift/api/Workflow/protocols/WorkflowAction/#workflowaction","text":"1 public protocol WorkflowAction Conforming types represent an action that advances a workflow. When applied, an action emits the next state and / or output for the workflow.","title":"WorkflowAction"},{"location":"swift/api/Workflow/protocols/WorkflowAction/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/protocols/WorkflowAction/#applytostate","text":"1 func apply ( toState state : inout WorkflowType . State ) -> WorkflowType . Output ? Applies this action to a given state of the workflow, optionally returning an output event. Parameter state: The current state of the workflow. The state is passed as an inout param, allowing actions to modify state during application. Returns: An optional output event for the workflow. If an output event is returned, it will be passed up the workflow hierarchy to this workflow\u2019s parent.","title":"apply(toState:)"},{"location":"swift/api/Workflow/protocols/WorkflowAction/#parameters","text":"Name Description state The current state of the workflow. The state is passed as an inout param, allowing actions to modify state during application.","title":"Parameters"},{"location":"swift/api/Workflow/protocols/WorkflowDebugger/","text":"PROTOCOL WorkflowDebugger \u00b6 1 public protocol WorkflowDebugger Defines a type that receives debug information about a running workflow hierarchy. Methods \u00b6 didEnterInitialState(snapshot:) \u00b6 1 func didEnterInitialState ( snapshot : WorkflowHierarchyDebugSnapshot ) Called once when the workflow hierarchy initializes. Parameter snapshot: Debug information about the workflow hierarchy. Parameters \u00b6 Name Description snapshot Debug information about the workflow hierarchy. didUpdate(snapshot:updateInfo:) \u00b6 1 func didUpdate ( snapshot : WorkflowHierarchyDebugSnapshot , updateInfo : WorkflowUpdateDebugInfo ) Called when an update occurs anywhere within the workflow hierarchy. Parameter snapshot: Debug information about the workflow hierarchy after the update. Parameter updateInfo: Information about the update. Parameters \u00b6 Name Description snapshot Debug information about the workflow hierarchy the update. updateInfo Information about the update.","title":"WorkflowDebugger"},{"location":"swift/api/Workflow/protocols/WorkflowDebugger/#workflowdebugger","text":"1 public protocol WorkflowDebugger Defines a type that receives debug information about a running workflow hierarchy.","title":"WorkflowDebugger"},{"location":"swift/api/Workflow/protocols/WorkflowDebugger/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/protocols/WorkflowDebugger/#didenterinitialstatesnapshot","text":"1 func didEnterInitialState ( snapshot : WorkflowHierarchyDebugSnapshot ) Called once when the workflow hierarchy initializes. Parameter snapshot: Debug information about the workflow hierarchy.","title":"didEnterInitialState(snapshot:)"},{"location":"swift/api/Workflow/protocols/WorkflowDebugger/#parameters","text":"Name Description snapshot Debug information about the workflow hierarchy.","title":"Parameters"},{"location":"swift/api/Workflow/protocols/WorkflowDebugger/#didupdatesnapshotupdateinfo","text":"1 func didUpdate ( snapshot : WorkflowHierarchyDebugSnapshot , updateInfo : WorkflowUpdateDebugInfo ) Called when an update occurs anywhere within the workflow hierarchy. Parameter snapshot: Debug information about the workflow hierarchy after the update. Parameter updateInfo: Information about the update.","title":"didUpdate(snapshot:updateInfo:)"},{"location":"swift/api/Workflow/protocols/WorkflowDebugger/#parameters_1","text":"Name Description snapshot Debug information about the workflow hierarchy the update. updateInfo Information about the update.","title":"Parameters"},{"location":"swift/api/Workflow/structs/AnyWorkflow/","text":"STRUCT AnyWorkflow \u00b6 1 public struct AnyWorkflow < Rendering , Output > A type-erased wrapper that contains a workflow with the given Rendering and Output types. Properties \u00b6 workflowType \u00b6 1 public var workflowType : Any . Type The underlying workflow\u2019s implementation type. Methods \u00b6 init(_:) \u00b6 1 public init < T : Workflow >( _ workflow : T ) where T . Rendering == Rendering , T . Output == Output Initializes a new type-erased wrapper for the given workflow.","title":"AnyWorkflow"},{"location":"swift/api/Workflow/structs/AnyWorkflow/#anyworkflow","text":"1 public struct AnyWorkflow < Rendering , Output > A type-erased wrapper that contains a workflow with the given Rendering and Output types.","title":"AnyWorkflow"},{"location":"swift/api/Workflow/structs/AnyWorkflow/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/structs/AnyWorkflow/#workflowtype","text":"1 public var workflowType : Any . Type The underlying workflow\u2019s implementation type.","title":"workflowType"},{"location":"swift/api/Workflow/structs/AnyWorkflow/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/structs/AnyWorkflow/#init_","text":"1 public init < T : Workflow >( _ workflow : T ) where T . Rendering == Rendering , T . Output == Output Initializes a new type-erased wrapper for the given workflow.","title":"init(_:)"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/","text":"STRUCT AnyWorkflowAction \u00b6 1 public struct AnyWorkflowAction < WorkflowType : Workflow >: WorkflowAction A type-erased workflow action. The AnyWorkflowAction type forwards apply to an underlying workflow action, hiding its specific underlying type, or to a closure that implements the apply logic. Methods \u00b6 init(_:) \u00b6 1 public init < E >( _ base : E ) where E : WorkflowAction , E . WorkflowType == WorkflowType Creates a type-erased workflow action that wraps the given instance. Parameter base: A workflow action to wrap. Parameters \u00b6 Name Description base A workflow action to wrap. init(_:) \u00b6 1 public init ( _ apply : @ escaping ( inout WorkflowType . State ) -> WorkflowType . Output ?) Creates a type-erased workflow action with the given apply implementation. Parameter apply: the apply function for the resulting action. Parameters \u00b6 Name Description apply the apply function for the resulting action. apply(toState:) \u00b6 1 public func apply ( toState state : inout WorkflowType . State ) -> WorkflowType . Output ? Parameters \u00b6 Name Description state The current state of the workflow. The state is passed as an inout param, allowing actions to modify state during application.","title":"AnyWorkflowAction"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#anyworkflowaction","text":"1 public struct AnyWorkflowAction < WorkflowType : Workflow >: WorkflowAction A type-erased workflow action. The AnyWorkflowAction type forwards apply to an underlying workflow action, hiding its specific underlying type, or to a closure that implements the apply logic.","title":"AnyWorkflowAction"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#init_","text":"1 public init < E >( _ base : E ) where E : WorkflowAction , E . WorkflowType == WorkflowType Creates a type-erased workflow action that wraps the given instance. Parameter base: A workflow action to wrap.","title":"init(_:)"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#parameters","text":"Name Description base A workflow action to wrap.","title":"Parameters"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#init__1","text":"1 public init ( _ apply : @ escaping ( inout WorkflowType . State ) -> WorkflowType . Output ?) Creates a type-erased workflow action with the given apply implementation. Parameter apply: the apply function for the resulting action.","title":"init(_:)"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#parameters_1","text":"Name Description apply the apply function for the resulting action.","title":"Parameters"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#applytostate","text":"1 public func apply ( toState state : inout WorkflowType . State ) -> WorkflowType . Output ?","title":"apply(toState:)"},{"location":"swift/api/Workflow/structs/AnyWorkflowAction/#parameters_2","text":"Name Description state The current state of the workflow. The state is passed as an inout param, allowing actions to modify state during application.","title":"Parameters"},{"location":"swift/api/Workflow/structs/Child/","text":"STRUCT Child \u00b6 1 public struct Child : Codable , Equatable Properties \u00b6 key \u00b6 1 public var key : String snapshot \u00b6 1 public var snapshot : WorkflowHierarchyDebugSnapshot","title":"Child"},{"location":"swift/api/Workflow/structs/Child/#child","text":"1 public struct Child : Codable , Equatable","title":"Child"},{"location":"swift/api/Workflow/structs/Child/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/structs/Child/#key","text":"1 public var key : String","title":"key"},{"location":"swift/api/Workflow/structs/Child/#snapshot","text":"1 public var snapshot : WorkflowHierarchyDebugSnapshot","title":"snapshot"},{"location":"swift/api/Workflow/structs/Sink/","text":"STRUCT Sink \u00b6 1 public struct Sink < Value > Sink is a type that receives incoming values (commonly events or WorkflowAction ) Use RenderContext.makeSink to create instances. Methods \u00b6 init(_:) \u00b6 1 public init ( _ onValue : @ escaping ( Value ) -> Void ) Initializes a new sink with the given closure. send(_:) \u00b6 1 public func send ( _ value : Value ) Sends a new event into the sink. Parameter event: The value to send into the sink. Parameters \u00b6 Name Description event The value to send into the sink. contraMap(_:) \u00b6 1 public func contraMap < NewValue >( _ transform : @ escaping ( NewValue ) -> Value ) -> Sink < NewValue > Generates a new sink of type NewValue. Given a transform closure, the following code is functionally equivalent: 1 sink.send(transform(value)) 1 sink.contraMap(transform).send(value) Trivia : Why is this called contraMap ? - map turns Type<T> into Type<U> via (T)->U . - contraMap turns Type<T> into Type<U> via (U)->T Another way to think about this is: map transforms a type by changing the output types of its API, while contraMap transforms a type by changing the input types of its API. Parameter transform: An escaping closure that transforms T into Event . Parameters \u00b6 Name Description transform An escaping closure that transforms T into Event .","title":"Sink"},{"location":"swift/api/Workflow/structs/Sink/#sink","text":"1 public struct Sink < Value > Sink is a type that receives incoming values (commonly events or WorkflowAction ) Use RenderContext.makeSink to create instances.","title":"Sink"},{"location":"swift/api/Workflow/structs/Sink/#methods","text":"","title":"Methods"},{"location":"swift/api/Workflow/structs/Sink/#init_","text":"1 public init ( _ onValue : @ escaping ( Value ) -> Void ) Initializes a new sink with the given closure.","title":"init(_:)"},{"location":"swift/api/Workflow/structs/Sink/#send_","text":"1 public func send ( _ value : Value ) Sends a new event into the sink. Parameter event: The value to send into the sink.","title":"send(_:)"},{"location":"swift/api/Workflow/structs/Sink/#parameters","text":"Name Description event The value to send into the sink.","title":"Parameters"},{"location":"swift/api/Workflow/structs/Sink/#contramap_","text":"1 public func contraMap < NewValue >( _ transform : @ escaping ( NewValue ) -> Value ) -> Sink < NewValue > Generates a new sink of type NewValue. Given a transform closure, the following code is functionally equivalent: 1 sink.send(transform(value)) 1 sink.contraMap(transform).send(value) Trivia : Why is this called contraMap ? - map turns Type<T> into Type<U> via (T)->U . - contraMap turns Type<T> into Type<U> via (U)->T Another way to think about this is: map transforms a type by changing the output types of its API, while contraMap transforms a type by changing the input types of its API. Parameter transform: An escaping closure that transforms T into Event .","title":"contraMap(_:)"},{"location":"swift/api/Workflow/structs/Sink/#parameters_1","text":"Name Description transform An escaping closure that transforms T into Event .","title":"Parameters"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot/","text":"STRUCT WorkflowHierarchyDebugSnapshot \u00b6 1 public struct WorkflowHierarchyDebugSnapshot : Codable , Equatable Properties \u00b6 workflowType \u00b6 1 public var workflowType : String stateDescription \u00b6 1 public var stateDescription : String children \u00b6 1 public var children : [ Child ]","title":"WorkflowHierarchyDebugSnapshot"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot/#workflowhierarchydebugsnapshot","text":"1 public struct WorkflowHierarchyDebugSnapshot : Codable , Equatable","title":"WorkflowHierarchyDebugSnapshot"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot/#workflowtype","text":"1 public var workflowType : String","title":"workflowType"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot/#statedescription","text":"1 public var stateDescription : String","title":"stateDescription"},{"location":"swift/api/Workflow/structs/WorkflowHierarchyDebugSnapshot/#children","text":"1 public var children : [ Child ]","title":"children"},{"location":"swift/api/Workflow/structs/WorkflowUpdateDebugInfo/","text":"STRUCT WorkflowUpdateDebugInfo \u00b6 1 public struct WorkflowUpdateDebugInfo : Codable , Equatable Properties \u00b6 workflowType \u00b6 1 public var workflowType : String kind \u00b6 1 public var kind : Kind","title":"WorkflowUpdateDebugInfo"},{"location":"swift/api/Workflow/structs/WorkflowUpdateDebugInfo/#workflowupdatedebuginfo","text":"1 public struct WorkflowUpdateDebugInfo : Codable , Equatable","title":"WorkflowUpdateDebugInfo"},{"location":"swift/api/Workflow/structs/WorkflowUpdateDebugInfo/#properties","text":"","title":"Properties"},{"location":"swift/api/Workflow/structs/WorkflowUpdateDebugInfo/#workflowtype","text":"1 public var workflowType : String","title":"workflowType"},{"location":"swift/api/Workflow/structs/WorkflowUpdateDebugInfo/#kind","text":"1 public var kind : Kind","title":"kind"},{"location":"swift/api/WorkflowTesting/","text":"Structs \u00b6 ExpectedOutput ExpectedState ExpectedWorker ExpectedWorkflow RenderExpectations WorkflowActionTester Classes \u00b6 RenderTester Extensions \u00b6 Workflow WorkflowAction Reference Documentation \u00b6 This reference documentation was generated with SourceDocs .","title":"WorkflowTesting "},{"location":"swift/api/WorkflowTesting/#structs","text":"ExpectedOutput ExpectedState ExpectedWorker ExpectedWorkflow RenderExpectations WorkflowActionTester","title":"Structs"},{"location":"swift/api/WorkflowTesting/#classes","text":"RenderTester","title":"Classes"},{"location":"swift/api/WorkflowTesting/#extensions","text":"Workflow WorkflowAction","title":"Extensions"},{"location":"swift/api/WorkflowTesting/#reference-documentation","text":"This reference documentation was generated with SourceDocs .","title":"Reference Documentation"},{"location":"swift/api/WorkflowTesting/classes/RenderTester/","text":"CLASS RenderTester \u00b6 1 public final class RenderTester < WorkflowType : Workflow > Testing helper for validating the behavior of calls to render . Usage: Set up a set of RenderExpectations and then validate with a call to render . Side-effects may be performed against the rendering to validate the behavior of actions. There is also a convenience render method where each expectation is an individual parameter. Child workflows will always be rendered based upon their initial state. To directly test actions and their effects, use the WorkflowActionTester . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 workflow .renderTester(initialState: TestWorkflow.State()) .render( with: RenderExpectations( expectedState: ExpectedState(state: TestWorkflow.State()), expectedOutput: ExpectedOutput(output: TestWorkflow.Output.finished), expectedWorkers: [ ExpectedWorker( worker: TestWorker(), output: TestWorker.Output.success), ..., ] expectedWorkflows: [ ExpectedWorkflow( type: ChildWorkflow.self, key: \"key\", rendering: \"rendering\", output: ChildWorkflow.Output.success), ..., ]), assertions: { rendering in XCTAssertEqual(\"expected text on rendering\", rendering.text) } .render(...) // continue testing. The state will be updated based on actions or outputs. Using the convenience API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 workflow .renderTester(initialState: TestWorkflow.State()) .render( expectedState: ExpectedState(state: TestWorkflow.State()), expectedOutput: ExpectedOutput(output: TestWorkflow.Output.finished), expectedWorkers: [ ExpectedWorker( worker: TestWorker(), output: TestWorker.Output.success), ..., ] expectedWorkflows: [ ExpectedWorkflow( type: ChildWorkflow.self, key: \"key\", rendering: \"rendering\", output: ChildWorkflow.Output.success) ..., ], assertions: { rendering in XCTAssertEqual(\"expected text on rendering\", rendering.text) } .render(...) // continue testing. The state will be updated based on actions or outputs. Validating the rendering only from the initial state provided by the workflow: 1 2 3 4 5 6 7 workflow .renderTester() .render( with: RenderExpectations(), assertions: { rendering in XCTAssertEqual(\"expected text on rendering\", rendering.text) } Validate the state was updated from a callback on the rendering: 1 2 3 4 5 6 7 8 9 workflow .renderTester() .render( with: RenderExpectations( expectedState: ExpectedState(state: TestWorkflow.State(text: \"updated\")), assertions: { rendering in XCTAssertEqual(\"expected text on rendering\", rendering.text) rendering.updateText(\"updated\") } Validate an output was received from the workflow. The action() on the rendering will cause an action that will return an output. 1 2 3 4 5 6 7 8 workflow .renderTester() .render( with: RenderExpectations( expectedState: ExpectedOutput(output: .success) assertions: { rendering in rendering.action() } Validate a worker is running, and simulate the effect of its output: 1 2 3 4 5 6 7 8 9 10 11 12 workflow .renderTester(initialState: TestWorkflow.State(loadingState: .loading)) .render( with: RenderExpectations( expectedState: ExpectedState(state: TestWorkflow.State(loadingState: .idle)), expectedWorkers: [ ExpectedWorker( worker: TestWorker(), output: TestWorker.Output.success), ..., ]), assertions: {} Validate a child workflow is run, and simulate the effect of its output: 1 2 3 4 5 6 7 8 9 10 11 12 workflow .renderTester(initialState: TestWorkflow.State(loadingState: .loading)) .render( with: RenderExpectations( expectedState: ExpectedState(state: TestWorkflow.State(loadingState: .idle)), expectedWorkflows: [ ExpectedWorkflow( type: ChildWorkflow.self, rendering: \"rendering\", output: ChildWorkflow.Output.success ]), assertions: {} Methods \u00b6 render(with:assertions:file:line:) \u00b6 1 public func render ( with expectations : RenderExpectations < WorkflowType >, assertions : ( WorkflowType . Rendering ) -> Void , file : StaticString = #file , line : UInt = #line ) -> RenderTester < WorkflowType > Call render with a set of expectations. If the expectations have not been fulfilled, the test will fail. render(expectedState:expectedOutput:expectedWorkers:expectedWorkflows:assertions:file:line:) \u00b6 1 2 3 4 5 6 7 8 public func render ( expectedState : ExpectedState < WorkflowType >? = nil , expectedOutput : ExpectedOutput < WorkflowType >? = nil , expectedWorkers : [ ExpectedWorker ] = [], expectedWorkflows : [ ExpectedWorkflow ] = [], assertions : ( WorkflowType . Rendering ) -> Void , file : StaticString = #file , line : UInt = #line ) -> RenderTester < WorkflowType > Convenience method for testing without creating an explicit RenderExpectation. assert(state:) \u00b6 1 public func assert ( state assertions : ( WorkflowType . State ) -> Void ) -> RenderTester < WorkflowType > Assert the internal state.","title":"RenderTester"},{"location":"swift/api/WorkflowTesting/classes/RenderTester/#rendertester","text":"1 public final class RenderTester < WorkflowType : Workflow > Testing helper for validating the behavior of calls to render . Usage: Set up a set of RenderExpectations and then validate with a call to render . Side-effects may be performed against the rendering to validate the behavior of actions. There is also a convenience render method where each expectation is an individual parameter. Child workflows will always be rendered based upon their initial state. To directly test actions and their effects, use the WorkflowActionTester . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 workflow .renderTester(initialState: TestWorkflow.State()) .render( with: RenderExpectations( expectedState: ExpectedState(state: TestWorkflow.State()), expectedOutput: ExpectedOutput(output: TestWorkflow.Output.finished), expectedWorkers: [ ExpectedWorker( worker: TestWorker(), output: TestWorker.Output.success), ..., ] expectedWorkflows: [ ExpectedWorkflow( type: ChildWorkflow.self, key: \"key\", rendering: \"rendering\", output: ChildWorkflow.Output.success), ..., ]), assertions: { rendering in XCTAssertEqual(\"expected text on rendering\", rendering.text) } .render(...) // continue testing. The state will be updated based on actions or outputs. Using the convenience API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 workflow .renderTester(initialState: TestWorkflow.State()) .render( expectedState: ExpectedState(state: TestWorkflow.State()), expectedOutput: ExpectedOutput(output: TestWorkflow.Output.finished), expectedWorkers: [ ExpectedWorker( worker: TestWorker(), output: TestWorker.Output.success), ..., ] expectedWorkflows: [ ExpectedWorkflow( type: ChildWorkflow.self, key: \"key\", rendering: \"rendering\", output: ChildWorkflow.Output.success) ..., ], assertions: { rendering in XCTAssertEqual(\"expected text on rendering\", rendering.text) } .render(...) // continue testing. The state will be updated based on actions or outputs. Validating the rendering only from the initial state provided by the workflow: 1 2 3 4 5 6 7 workflow .renderTester() .render( with: RenderExpectations(), assertions: { rendering in XCTAssertEqual(\"expected text on rendering\", rendering.text) } Validate the state was updated from a callback on the rendering: 1 2 3 4 5 6 7 8 9 workflow .renderTester() .render( with: RenderExpectations( expectedState: ExpectedState(state: TestWorkflow.State(text: \"updated\")), assertions: { rendering in XCTAssertEqual(\"expected text on rendering\", rendering.text) rendering.updateText(\"updated\") } Validate an output was received from the workflow. The action() on the rendering will cause an action that will return an output. 1 2 3 4 5 6 7 8 workflow .renderTester() .render( with: RenderExpectations( expectedState: ExpectedOutput(output: .success) assertions: { rendering in rendering.action() } Validate a worker is running, and simulate the effect of its output: 1 2 3 4 5 6 7 8 9 10 11 12 workflow .renderTester(initialState: TestWorkflow.State(loadingState: .loading)) .render( with: RenderExpectations( expectedState: ExpectedState(state: TestWorkflow.State(loadingState: .idle)), expectedWorkers: [ ExpectedWorker( worker: TestWorker(), output: TestWorker.Output.success), ..., ]), assertions: {} Validate a child workflow is run, and simulate the effect of its output: 1 2 3 4 5 6 7 8 9 10 11 12 workflow .renderTester(initialState: TestWorkflow.State(loadingState: .loading)) .render( with: RenderExpectations( expectedState: ExpectedState(state: TestWorkflow.State(loadingState: .idle)), expectedWorkflows: [ ExpectedWorkflow( type: ChildWorkflow.self, rendering: \"rendering\", output: ChildWorkflow.Output.success ]), assertions: {}","title":"RenderTester"},{"location":"swift/api/WorkflowTesting/classes/RenderTester/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/classes/RenderTester/#renderwithassertionsfileline","text":"1 public func render ( with expectations : RenderExpectations < WorkflowType >, assertions : ( WorkflowType . Rendering ) -> Void , file : StaticString = #file , line : UInt = #line ) -> RenderTester < WorkflowType > Call render with a set of expectations. If the expectations have not been fulfilled, the test will fail.","title":"render(with:assertions:file:line:)"},{"location":"swift/api/WorkflowTesting/classes/RenderTester/#renderexpectedstateexpectedoutputexpectedworkersexpectedworkflowsassertionsfileline","text":"1 2 3 4 5 6 7 8 public func render ( expectedState : ExpectedState < WorkflowType >? = nil , expectedOutput : ExpectedOutput < WorkflowType >? = nil , expectedWorkers : [ ExpectedWorker ] = [], expectedWorkflows : [ ExpectedWorkflow ] = [], assertions : ( WorkflowType . Rendering ) -> Void , file : StaticString = #file , line : UInt = #line ) -> RenderTester < WorkflowType > Convenience method for testing without creating an explicit RenderExpectation.","title":"render(expectedState:expectedOutput:expectedWorkers:expectedWorkflows:assertions:file:line:)"},{"location":"swift/api/WorkflowTesting/classes/RenderTester/#assertstate","text":"1 public func assert ( state assertions : ( WorkflowType . State ) -> Void ) -> RenderTester < WorkflowType > Assert the internal state.","title":"assert(state:)"},{"location":"swift/api/WorkflowTesting/extensions/Workflow/","text":"EXTENSION Workflow \u00b6 Methods \u00b6 renderTester(initialState:) \u00b6 1 public func renderTester ( initialState : Self . State ) -> RenderTester < Self > Returns a RenderTester with a specified initial state. renderTester() \u00b6 1 public func renderTester () -> RenderTester < Self > Returns a RenderTester with an initial state provided by self.makeInitialState()","title":"Workflow"},{"location":"swift/api/WorkflowTesting/extensions/Workflow/#workflow","text":"","title":"Workflow"},{"location":"swift/api/WorkflowTesting/extensions/Workflow/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/extensions/Workflow/#rendertesterinitialstate","text":"1 public func renderTester ( initialState : Self . State ) -> RenderTester < Self > Returns a RenderTester with a specified initial state.","title":"renderTester(initialState:)"},{"location":"swift/api/WorkflowTesting/extensions/Workflow/#rendertester","text":"1 public func renderTester () -> RenderTester < Self > Returns a RenderTester with an initial state provided by self.makeInitialState()","title":"renderTester()"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowAction/","text":"EXTENSION WorkflowAction \u00b6 Methods \u00b6 tester(withState:) \u00b6 1 public static func tester ( withState state : WorkflowType . State ) -> WorkflowActionTester < WorkflowType , Self > Returns a state tester containing self .","title":"WorkflowAction"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowAction/#workflowaction","text":"","title":"WorkflowAction"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowAction/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/extensions/WorkflowAction/#testerwithstate","text":"1 public static func tester ( withState state : WorkflowType . State ) -> WorkflowActionTester < WorkflowType , Self > Returns a state tester containing self .","title":"tester(withState:)"},{"location":"swift/api/WorkflowTesting/structs/ExpectedOutput/","text":"STRUCT ExpectedOutput \u00b6 1 public struct ExpectedOutput < WorkflowType : Workflow > Methods \u00b6 init(output:isEquivalent:) \u00b6 1 public init < Output >( output : Output , isEquivalent : @ escaping ( Output , Output ) -> Bool ) where Output == WorkflowType . Output init(output:) \u00b6 1 public init < Output >( output : Output ) where Output == WorkflowType . Output , Output : Equatable","title":"ExpectedOutput"},{"location":"swift/api/WorkflowTesting/structs/ExpectedOutput/#expectedoutput","text":"1 public struct ExpectedOutput < WorkflowType : Workflow >","title":"ExpectedOutput"},{"location":"swift/api/WorkflowTesting/structs/ExpectedOutput/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/structs/ExpectedOutput/#initoutputisequivalent","text":"1 public init < Output >( output : Output , isEquivalent : @ escaping ( Output , Output ) -> Bool ) where Output == WorkflowType . Output","title":"init(output:isEquivalent:)"},{"location":"swift/api/WorkflowTesting/structs/ExpectedOutput/#initoutput","text":"1 public init < Output >( output : Output ) where Output == WorkflowType . Output , Output : Equatable","title":"init(output:)"},{"location":"swift/api/WorkflowTesting/structs/ExpectedState/","text":"STRUCT ExpectedState \u00b6 1 public struct ExpectedState < WorkflowType : Workflow > Methods \u00b6 init(state:isEquivalent:) \u00b6 1 public init < State >( state : State , isEquivalent : @ escaping ( State , State ) -> Bool ) where State == WorkflowType . State Create a new expected state from a state with an equivalence block. isEquivalent will be called to validate that the expected state matches the actual state after a render pass. init(state:) \u00b6 1 public init < State >( state : State ) where WorkflowType . State == State , State : Equatable","title":"ExpectedState"},{"location":"swift/api/WorkflowTesting/structs/ExpectedState/#expectedstate","text":"1 public struct ExpectedState < WorkflowType : Workflow >","title":"ExpectedState"},{"location":"swift/api/WorkflowTesting/structs/ExpectedState/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/structs/ExpectedState/#initstateisequivalent","text":"1 public init < State >( state : State , isEquivalent : @ escaping ( State , State ) -> Bool ) where State == WorkflowType . State Create a new expected state from a state with an equivalence block. isEquivalent will be called to validate that the expected state matches the actual state after a render pass.","title":"init(state:isEquivalent:)"},{"location":"swift/api/WorkflowTesting/structs/ExpectedState/#initstate","text":"1 public init < State >( state : State ) where WorkflowType . State == State , State : Equatable","title":"init(state:)"},{"location":"swift/api/WorkflowTesting/structs/ExpectedWorker/","text":"STRUCT ExpectedWorker \u00b6 1 public struct ExpectedWorker Methods \u00b6 init(worker:output:) \u00b6 1 public init < WorkerType : Worker >( worker : WorkerType , output : WorkerType . Output ? = nil ) Create a new expected worker with an optional output. If output is not nil, it will be emitted when this worker is declared in the render pass.","title":"ExpectedWorker"},{"location":"swift/api/WorkflowTesting/structs/ExpectedWorker/#expectedworker","text":"1 public struct ExpectedWorker","title":"ExpectedWorker"},{"location":"swift/api/WorkflowTesting/structs/ExpectedWorker/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/structs/ExpectedWorker/#initworkeroutput","text":"1 public init < WorkerType : Worker >( worker : WorkerType , output : WorkerType . Output ? = nil ) Create a new expected worker with an optional output. If output is not nil, it will be emitted when this worker is declared in the render pass.","title":"init(worker:output:)"},{"location":"swift/api/WorkflowTesting/structs/ExpectedWorkflow/","text":"STRUCT ExpectedWorkflow \u00b6 1 public struct ExpectedWorkflow Methods \u00b6 init(type:key:rendering:output:) \u00b6 1 public init < WorkflowType : Workflow >( type : WorkflowType . Type , key : String = \"\" , rendering : WorkflowType . Rendering , output : WorkflowType . Output ? = nil )","title":"ExpectedWorkflow"},{"location":"swift/api/WorkflowTesting/structs/ExpectedWorkflow/#expectedworkflow","text":"1 public struct ExpectedWorkflow","title":"ExpectedWorkflow"},{"location":"swift/api/WorkflowTesting/structs/ExpectedWorkflow/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/structs/ExpectedWorkflow/#inittypekeyrenderingoutput","text":"1 public init < WorkflowType : Workflow >( type : WorkflowType . Type , key : String = \"\" , rendering : WorkflowType . Rendering , output : WorkflowType . Output ? = nil )","title":"init(type:key:rendering:output:)"},{"location":"swift/api/WorkflowTesting/structs/RenderExpectations/","text":"STRUCT RenderExpectations \u00b6 1 public struct RenderExpectations < WorkflowType : Workflow > A set of expectations for use with the WorkflowRenderTester . All of the expectations must be fulfilled for a render test to pass. Methods \u00b6 init(expectedState:expectedOutput:expectedWorkers:expectedWorkflows:) \u00b6 1 2 3 4 5 public init ( expectedState : ExpectedState < WorkflowType >? = nil , expectedOutput : ExpectedOutput < WorkflowType >? = nil , expectedWorkers : [ ExpectedWorker ] = [], expectedWorkflows : [ ExpectedWorkflow ] = [])","title":"RenderExpectations"},{"location":"swift/api/WorkflowTesting/structs/RenderExpectations/#renderexpectations","text":"1 public struct RenderExpectations < WorkflowType : Workflow > A set of expectations for use with the WorkflowRenderTester . All of the expectations must be fulfilled for a render test to pass.","title":"RenderExpectations"},{"location":"swift/api/WorkflowTesting/structs/RenderExpectations/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/structs/RenderExpectations/#initexpectedstateexpectedoutputexpectedworkersexpectedworkflows","text":"1 2 3 4 5 public init ( expectedState : ExpectedState < WorkflowType >? = nil , expectedOutput : ExpectedOutput < WorkflowType >? = nil , expectedWorkers : [ ExpectedWorker ] = [], expectedWorkflows : [ ExpectedWorkflow ] = [])","title":"init(expectedState:expectedOutput:expectedWorkers:expectedWorkflows:)"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/","text":"STRUCT WorkflowActionTester \u00b6 1 public struct WorkflowActionTester < WorkflowType , Action > where Action : WorkflowAction , Action . WorkflowType == WorkflowType Testing helper that chains event sending and state/output assertions to make tests easier to write. 1 2 3 4 5 6 7 8 9 10 11 reducer .tester(withState: .firstState) .assertState { state in XCTAssertEqual(.firstState, state) } .send(event: .exampleEvent) { output in XCTAssertEqual(.finished, output) } .assertState { state in XCTAssertEqual(.differentState, state) } Methods \u00b6 send(action:outputAssertions:) \u00b6 1 public func send ( action : Action , outputAssertions : ( WorkflowType . Output ?) -> Void = { _ in }) -> WorkflowActionTester < WorkflowType , Action > Sends an event to the reducer. parameter event: The event to send. parameter outputAssertions: An optional closure that runs validations on the output generated by the reducer. returns: A new state tester containing the state after the update. Parameters \u00b6 Name Description event The event to send. outputAssertions An optional closure that runs validations on the output generated by the reducer. assertState(_:) \u00b6 1 public func assertState ( _ assertions : ( WorkflowType . State ) -> Void ) -> WorkflowActionTester < WorkflowType , Action > Invokes the given closure (which is intended to contain test assertions) with the current state. parameter assertions: A closure that accepts a single state value. returns: A tester containing the current state. Parameters \u00b6 Name Description assertions A closure that accepts a single state value.","title":"WorkflowActionTester"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/#workflowactiontester","text":"1 public struct WorkflowActionTester < WorkflowType , Action > where Action : WorkflowAction , Action . WorkflowType == WorkflowType Testing helper that chains event sending and state/output assertions to make tests easier to write. 1 2 3 4 5 6 7 8 9 10 11 reducer .tester(withState: .firstState) .assertState { state in XCTAssertEqual(.firstState, state) } .send(event: .exampleEvent) { output in XCTAssertEqual(.finished, output) } .assertState { state in XCTAssertEqual(.differentState, state) }","title":"WorkflowActionTester"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/#sendactionoutputassertions","text":"1 public func send ( action : Action , outputAssertions : ( WorkflowType . Output ?) -> Void = { _ in }) -> WorkflowActionTester < WorkflowType , Action > Sends an event to the reducer. parameter event: The event to send. parameter outputAssertions: An optional closure that runs validations on the output generated by the reducer. returns: A new state tester containing the state after the update.","title":"send(action:outputAssertions:)"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/#parameters","text":"Name Description event The event to send. outputAssertions An optional closure that runs validations on the output generated by the reducer.","title":"Parameters"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/#assertstate_","text":"1 public func assertState ( _ assertions : ( WorkflowType . State ) -> Void ) -> WorkflowActionTester < WorkflowType , Action > Invokes the given closure (which is intended to contain test assertions) with the current state. parameter assertions: A closure that accepts a single state value. returns: A tester containing the current state.","title":"assertState(_:)"},{"location":"swift/api/WorkflowTesting/structs/WorkflowActionTester/#parameters_1","text":"Name Description assertions A closure that accepts a single state value.","title":"Parameters"},{"location":"swift/api/WorkflowUI/","text":"Protocols \u00b6 Screen ViewEnvironmentKey Structs \u00b6 AnyScreen ViewControllerDescription ViewEnvironment Classes \u00b6 ContainerViewController DescribedViewController ScreenViewController Extensions \u00b6 ScreenViewController Reference Documentation \u00b6 This reference documentation was generated with SourceDocs .","title":"WorkflowUI "},{"location":"swift/api/WorkflowUI/#protocols","text":"Screen ViewEnvironmentKey","title":"Protocols"},{"location":"swift/api/WorkflowUI/#structs","text":"AnyScreen ViewControllerDescription ViewEnvironment","title":"Structs"},{"location":"swift/api/WorkflowUI/#classes","text":"ContainerViewController DescribedViewController ScreenViewController","title":"Classes"},{"location":"swift/api/WorkflowUI/#extensions","text":"ScreenViewController","title":"Extensions"},{"location":"swift/api/WorkflowUI/#reference-documentation","text":"This reference documentation was generated with SourceDocs .","title":"Reference Documentation"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/","text":"CLASS ContainerViewController \u00b6 1 public final class ContainerViewController < Output , ScreenType >: UIViewController where ScreenType : Screen Drives view controllers from a root Workflow. Properties \u00b6 output \u00b6 1 public let output : Signal < Output , Never > Emits output events from the bound workflow. rootViewEnvironment \u00b6 1 public var rootViewEnvironment : ViewEnvironment childForStatusBarStyle \u00b6 1 public override var childForStatusBarStyle : UIViewController ? childForStatusBarHidden \u00b6 1 public override var childForStatusBarHidden : UIViewController ? childForHomeIndicatorAutoHidden \u00b6 1 public override var childForHomeIndicatorAutoHidden : UIViewController ? childForScreenEdgesDeferringSystemGestures \u00b6 1 public override var childForScreenEdgesDeferringSystemGestures : UIViewController ? supportedInterfaceOrientations \u00b6 1 public override var supportedInterfaceOrientations : UIInterfaceOrientationMask Methods \u00b6 init(workflow:rootViewEnvironment:) \u00b6 1 public convenience init < W : Workflow >( workflow : W , rootViewEnvironment : ViewEnvironment = . empty ) where W . Rendering == ScreenType , W . Output == Output init(coder:) \u00b6 1 required public init ?( coder aDecoder : NSCoder ) viewDidLoad() \u00b6 1 override public func viewDidLoad () viewDidLayoutSubviews() \u00b6 1 override public func viewDidLayoutSubviews ()","title":"ContainerViewController"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#containerviewcontroller","text":"1 public final class ContainerViewController < Output , ScreenType >: UIViewController where ScreenType : Screen Drives view controllers from a root Workflow.","title":"ContainerViewController"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#properties","text":"","title":"Properties"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#output","text":"1 public let output : Signal < Output , Never > Emits output events from the bound workflow.","title":"output"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#rootviewenvironment","text":"1 public var rootViewEnvironment : ViewEnvironment","title":"rootViewEnvironment"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#childforstatusbarstyle","text":"1 public override var childForStatusBarStyle : UIViewController ?","title":"childForStatusBarStyle"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#childforstatusbarhidden","text":"1 public override var childForStatusBarHidden : UIViewController ?","title":"childForStatusBarHidden"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#childforhomeindicatorautohidden","text":"1 public override var childForHomeIndicatorAutoHidden : UIViewController ?","title":"childForHomeIndicatorAutoHidden"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#childforscreenedgesdeferringsystemgestures","text":"1 public override var childForScreenEdgesDeferringSystemGestures : UIViewController ?","title":"childForScreenEdgesDeferringSystemGestures"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#supportedinterfaceorientations","text":"1 public override var supportedInterfaceOrientations : UIInterfaceOrientationMask","title":"supportedInterfaceOrientations"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#initworkflowrootviewenvironment","text":"1 public convenience init < W : Workflow >( workflow : W , rootViewEnvironment : ViewEnvironment = . empty ) where W . Rendering == ScreenType , W . Output == Output","title":"init(workflow:rootViewEnvironment:)"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#initcoder","text":"1 required public init ?( coder aDecoder : NSCoder )","title":"init(coder:)"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#viewdidload","text":"1 override public func viewDidLoad ()","title":"viewDidLoad()"},{"location":"swift/api/WorkflowUI/classes/ContainerViewController/#viewdidlayoutsubviews","text":"1 override public func viewDidLayoutSubviews ()","title":"viewDidLayoutSubviews()"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/","text":"CLASS DescribedViewController \u00b6 1 public final class DescribedViewController : UIViewController Properties \u00b6 childForStatusBarStyle \u00b6 1 public override var childForStatusBarStyle : UIViewController ? childForStatusBarHidden \u00b6 1 public override var childForStatusBarHidden : UIViewController ? childForHomeIndicatorAutoHidden \u00b6 1 public override var childForHomeIndicatorAutoHidden : UIViewController ? childForScreenEdgesDeferringSystemGestures \u00b6 1 public override var childForScreenEdgesDeferringSystemGestures : UIViewController ? supportedInterfaceOrientations \u00b6 1 public override var supportedInterfaceOrientations : UIInterfaceOrientationMask Methods \u00b6 init(description:) \u00b6 1 public init ( description : ViewControllerDescription ) init(screen:environment:) \u00b6 1 public convenience init < S : Screen >( screen : S , environment : ViewEnvironment ) update(description:) \u00b6 1 public func update ( description : ViewControllerDescription ) update(screen:environment:) \u00b6 1 public func update < S : Screen >( screen : S , environment : ViewEnvironment ) viewDidLoad() \u00b6 1 public override func viewDidLoad () viewDidLayoutSubviews() \u00b6 1 public override func viewDidLayoutSubviews ()","title":"DescribedViewController"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#describedviewcontroller","text":"1 public final class DescribedViewController : UIViewController","title":"DescribedViewController"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#properties","text":"","title":"Properties"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#childforstatusbarstyle","text":"1 public override var childForStatusBarStyle : UIViewController ?","title":"childForStatusBarStyle"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#childforstatusbarhidden","text":"1 public override var childForStatusBarHidden : UIViewController ?","title":"childForStatusBarHidden"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#childforhomeindicatorautohidden","text":"1 public override var childForHomeIndicatorAutoHidden : UIViewController ?","title":"childForHomeIndicatorAutoHidden"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#childforscreenedgesdeferringsystemgestures","text":"1 public override var childForScreenEdgesDeferringSystemGestures : UIViewController ?","title":"childForScreenEdgesDeferringSystemGestures"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#supportedinterfaceorientations","text":"1 public override var supportedInterfaceOrientations : UIInterfaceOrientationMask","title":"supportedInterfaceOrientations"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#initdescription","text":"1 public init ( description : ViewControllerDescription )","title":"init(description:)"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#initscreenenvironment","text":"1 public convenience init < S : Screen >( screen : S , environment : ViewEnvironment )","title":"init(screen:environment:)"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#updatedescription","text":"1 public func update ( description : ViewControllerDescription )","title":"update(description:)"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#updatescreenenvironment","text":"1 public func update < S : Screen >( screen : S , environment : ViewEnvironment )","title":"update(screen:environment:)"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#viewdidload","text":"1 public override func viewDidLoad ()","title":"viewDidLoad()"},{"location":"swift/api/WorkflowUI/classes/DescribedViewController/#viewdidlayoutsubviews","text":"1 public override func viewDidLayoutSubviews ()","title":"viewDidLayoutSubviews()"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/","text":"CLASS ScreenViewController \u00b6 1 open class ScreenViewController < ScreenType : Screen >: UIViewController Generic base class that can be subclassed in order to to define a UI implementation that is powered by the given screen type. Using this base class, a screen can be implemented as: 1 2 3 4 5 6 7 8 9 10 11 struct MyScreen: Screen { func viewControllerDescription(environment: ViewEnvironment) -> ViewControllerDescription { return MyScreenViewController.description(for: self) } } private class MyScreenViewController: ScreenViewController<MyScreen> { override func screenDidChange(from previousScreen: MyScreen, previousEnvironment: ViewEnvironment) { // \u2026 update views as necessary } } Properties \u00b6 screen \u00b6 1 private ( set ) public final var screen : ScreenType screenType \u00b6 1 public final var screenType : Screen . Type environment \u00b6 1 private ( set ) public final var environment : ViewEnvironment Methods \u00b6 init(screen:environment:) \u00b6 1 public required init ( screen : ScreenType , environment : ViewEnvironment ) init(coder:) \u00b6 update(screen:environment:) \u00b6 1 public final func update ( screen : ScreenType , environment : ViewEnvironment ) screenDidChange(from:previousEnvironment:) \u00b6 1 open func screenDidChange ( from previousScreen : ScreenType , previousEnvironment : ViewEnvironment ) Subclasses should override this method in order to update any relevant UI bits when the screen model changes.","title":"ScreenViewController"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#screenviewcontroller","text":"1 open class ScreenViewController < ScreenType : Screen >: UIViewController Generic base class that can be subclassed in order to to define a UI implementation that is powered by the given screen type. Using this base class, a screen can be implemented as: 1 2 3 4 5 6 7 8 9 10 11 struct MyScreen: Screen { func viewControllerDescription(environment: ViewEnvironment) -> ViewControllerDescription { return MyScreenViewController.description(for: self) } } private class MyScreenViewController: ScreenViewController<MyScreen> { override func screenDidChange(from previousScreen: MyScreen, previousEnvironment: ViewEnvironment) { // \u2026 update views as necessary } }","title":"ScreenViewController"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#properties","text":"","title":"Properties"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#screen","text":"1 private ( set ) public final var screen : ScreenType","title":"screen"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#screentype","text":"1 public final var screenType : Screen . Type","title":"screenType"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#environment","text":"1 private ( set ) public final var environment : ViewEnvironment","title":"environment"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#initscreenenvironment","text":"1 public required init ( screen : ScreenType , environment : ViewEnvironment )","title":"init(screen:environment:)"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#initcoder","text":"","title":"init(coder:)"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#updatescreenenvironment","text":"1 public final func update ( screen : ScreenType , environment : ViewEnvironment )","title":"update(screen:environment:)"},{"location":"swift/api/WorkflowUI/classes/ScreenViewController/#screendidchangefrompreviousenvironment","text":"1 open func screenDidChange ( from previousScreen : ScreenType , previousEnvironment : ViewEnvironment ) Subclasses should override this method in order to update any relevant UI bits when the screen model changes.","title":"screenDidChange(from:previousEnvironment:)"},{"location":"swift/api/WorkflowUI/extensions/ScreenViewController/","text":"EXTENSION ScreenViewController \u00b6 Methods \u00b6 description(for:environment:) \u00b6 1 public final class func description ( for screen : ScreenType , environment : ViewEnvironment ) -> ViewControllerDescription Convenience to create a view controller description for the given screen value. See the example on the comment for ScreenViewController for usage.","title":"ScreenViewController"},{"location":"swift/api/WorkflowUI/extensions/ScreenViewController/#screenviewcontroller","text":"","title":"ScreenViewController"},{"location":"swift/api/WorkflowUI/extensions/ScreenViewController/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/extensions/ScreenViewController/#descriptionforenvironment","text":"1 public final class func description ( for screen : ScreenType , environment : ViewEnvironment ) -> ViewControllerDescription Convenience to create a view controller description for the given screen value. See the example on the comment for ScreenViewController for usage.","title":"description(for:environment:)"},{"location":"swift/api/WorkflowUI/protocols/Screen/","text":"PROTOCOL Screen \u00b6 1 public protocol Screen Screens are the building blocks of an interactive application. Conforming types contain any information needed to populate a screen: data, styling, event handlers, etc. Methods \u00b6 viewControllerDescription(environment:) \u00b6 1 func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription A view controller description that acts as a recipe to either build or update a previously-built view controller to match this screen.","title":"Screen"},{"location":"swift/api/WorkflowUI/protocols/Screen/#screen","text":"1 public protocol Screen Screens are the building blocks of an interactive application. Conforming types contain any information needed to populate a screen: data, styling, event handlers, etc.","title":"Screen"},{"location":"swift/api/WorkflowUI/protocols/Screen/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/protocols/Screen/#viewcontrollerdescriptionenvironment","text":"1 func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription A view controller description that acts as a recipe to either build or update a previously-built view controller to match this screen.","title":"viewControllerDescription(environment:)"},{"location":"swift/api/WorkflowUI/protocols/ViewEnvironmentKey/","text":"PROTOCOL ViewEnvironmentKey \u00b6 1 public protocol ViewEnvironmentKey A key into the ViewEnvironment. Environment keys are associated with a specific type of value ( Value ) and must declare a default value. Typically the key conforming to ViewEnvironmentKey will be private, and you are encouraged to provide a convenience accessor on ViewEnvironment as in the following example: 1 2 3 4 5 6 7 8 9 10 11 private enum ThemeKey: ViewEnvironmentKey { typealias Value = Theme var defaultValue: Theme } extension ViewEnvironment { public var theme: Theme { get { self[ThemeKey.self] } set { self[ThemeKey.self] = newValue } } }","title":"ViewEnvironmentKey"},{"location":"swift/api/WorkflowUI/protocols/ViewEnvironmentKey/#viewenvironmentkey","text":"1 public protocol ViewEnvironmentKey A key into the ViewEnvironment. Environment keys are associated with a specific type of value ( Value ) and must declare a default value. Typically the key conforming to ViewEnvironmentKey will be private, and you are encouraged to provide a convenience accessor on ViewEnvironment as in the following example: 1 2 3 4 5 6 7 8 9 10 11 private enum ThemeKey: ViewEnvironmentKey { typealias Value = Theme var defaultValue: Theme } extension ViewEnvironment { public var theme: Theme { get { self[ThemeKey.self] } set { self[ThemeKey.self] = newValue } } }","title":"ViewEnvironmentKey"},{"location":"swift/api/WorkflowUI/structs/AnyScreen/","text":"STRUCT AnyScreen \u00b6 1 public struct AnyScreen : Screen Methods \u00b6 init(_:) \u00b6 1 public init < T : Screen >( _ screen : T ) viewControllerDescription(environment:) \u00b6 1 public func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription","title":"AnyScreen"},{"location":"swift/api/WorkflowUI/structs/AnyScreen/#anyscreen","text":"1 public struct AnyScreen : Screen","title":"AnyScreen"},{"location":"swift/api/WorkflowUI/structs/AnyScreen/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/structs/AnyScreen/#init_","text":"1 public init < T : Screen >( _ screen : T )","title":"init(_:)"},{"location":"swift/api/WorkflowUI/structs/AnyScreen/#viewcontrollerdescriptionenvironment","text":"1 public func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription","title":"viewControllerDescription(environment:)"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/","text":"STRUCT ViewControllerDescription \u00b6 1 public struct ViewControllerDescription A ViewControllerDescription acts as a recipe for building and updating a specific UIViewController. Methods \u00b6 init(type:build:update:) \u00b6 1 public init < VC : UIViewController >( type : VC . Type = VC . self , build : @ escaping () -> VC , update : @ escaping ( VC ) -> Void ) Constructs a view controller description by providing a closure used to build and update a specific view controller type. Parameters: type: The type of view controller produced by this description. Typically, should should be able to omit this parameter, but in cases where type inference has trouble, it\u2019s offered as an escape hatch. build: Closure that produces a new instance of the view controller update: Closure that updates the given view controller Parameters \u00b6 Name Description type The type of view controller produced by this description. Typically, should should be able to omit this parameter, but in cases where type inference has trouble, it\u2019s offered as an escape hatch. build Closure that produces a new instance of the view controller update Closure that updates the given view controller","title":"ViewControllerDescription"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/#viewcontrollerdescription","text":"1 public struct ViewControllerDescription A ViewControllerDescription acts as a recipe for building and updating a specific UIViewController.","title":"ViewControllerDescription"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/#inittypebuildupdate","text":"1 public init < VC : UIViewController >( type : VC . Type = VC . self , build : @ escaping () -> VC , update : @ escaping ( VC ) -> Void ) Constructs a view controller description by providing a closure used to build and update a specific view controller type. Parameters: type: The type of view controller produced by this description. Typically, should should be able to omit this parameter, but in cases where type inference has trouble, it\u2019s offered as an escape hatch. build: Closure that produces a new instance of the view controller update: Closure that updates the given view controller","title":"init(type:build:update:)"},{"location":"swift/api/WorkflowUI/structs/ViewControllerDescription/#parameters","text":"Name Description type The type of view controller produced by this description. Typically, should should be able to omit this parameter, but in cases where type inference has trouble, it\u2019s offered as an escape hatch. build Closure that produces a new instance of the view controller update Closure that updates the given view controller","title":"Parameters"},{"location":"swift/api/WorkflowUI/structs/ViewEnvironment/","text":"STRUCT ViewEnvironment \u00b6 1 public struct ViewEnvironment ViewEnvironment acts as a container for values to flow down the view-side of a rendering tree (as opposed to being passed down through Workflows). This will often be used by containers to let their children know in what context they\u2019re appearing (for example, a split screen container may set the environment of its two children according to which position they\u2019re appearing in). Methods \u00b6 setting(key:to:) \u00b6 1 public func setting < Key >( key : Key . Type , to value : Key . Value ) -> ViewEnvironment where Key : ViewEnvironmentKey Returns a new ViewEnvironment with the given value set for the given environment key. This is provided as a convenience for modifying the environment while passing it down to children screens without the need for an intermediate mutable value. It is functionally equivalent to the subscript setter. setting(keyPath:to:) \u00b6 1 public func setting < Value >( keyPath : WritableKeyPath < ViewEnvironment , Value >, to value : Value ) -> ViewEnvironment Returns a new ViewEnvironment with the given value set for the given key path. This is provided as a convenience for modifying the environment while passing it down to children screens. The following are functionally equivalent: 1 2 var newEnvironment = environment newEnvironment.someProperty = 42 and 1 let newEnvironment = environment.setting(\\.someProperty, to: 42)","title":"ViewEnvironment"},{"location":"swift/api/WorkflowUI/structs/ViewEnvironment/#viewenvironment","text":"1 public struct ViewEnvironment ViewEnvironment acts as a container for values to flow down the view-side of a rendering tree (as opposed to being passed down through Workflows). This will often be used by containers to let their children know in what context they\u2019re appearing (for example, a split screen container may set the environment of its two children according to which position they\u2019re appearing in).","title":"ViewEnvironment"},{"location":"swift/api/WorkflowUI/structs/ViewEnvironment/#methods","text":"","title":"Methods"},{"location":"swift/api/WorkflowUI/structs/ViewEnvironment/#settingkeyto","text":"1 public func setting < Key >( key : Key . Type , to value : Key . Value ) -> ViewEnvironment where Key : ViewEnvironmentKey Returns a new ViewEnvironment with the given value set for the given environment key. This is provided as a convenience for modifying the environment while passing it down to children screens without the need for an intermediate mutable value. It is functionally equivalent to the subscript setter.","title":"setting(key:to:)"},{"location":"swift/api/WorkflowUI/structs/ViewEnvironment/#settingkeypathto","text":"1 public func setting < Value >( keyPath : WritableKeyPath < ViewEnvironment , Value >, to value : Value ) -> ViewEnvironment Returns a new ViewEnvironment with the given value set for the given key path. This is provided as a convenience for modifying the environment while passing it down to children screens. The following are functionally equivalent: 1 2 var newEnvironment = environment newEnvironment.someProperty = 42 and 1 let newEnvironment = environment.setting(\\.someProperty, to: 42)","title":"setting(keyPath:to:)"},{"location":"tutorial/","text":"Swift \u00b6 Tip For a comprehensive tutorial with code that you can build and follow along with, see the Tutorials in the repo. This section will be restructured soon to incorporate that and Kotlin tutorials. The Workflow infrastructure is split into several modules. Workflow \u00b6 The Workflow library contains the core types that are used to implement state-driven workflows, including the Workflow protocol and related indrastructure. WorkflowUI \u00b6 Contains the basic infrastructure required to build a Workflow-based application that uses UIKit . Workflow for iOS makes extensive use of ReactiveSwift . If you are new to reactive programming, you may want to familiarize yourself with some of the basics. Workflow takes care of a lot of the reactive plumbing in a typical application, but you will have a better time if you understand what the framework is doing. Core Reactive Primitives Basic Operators How does ReactiveSwift relate to RxSwift? Next Steps \u00b6 Tooling Adding Workflow to a Project Building a Workflow Building a View Controller from a Screen Using a Workflow to Show UI","title":"Overview"},{"location":"tutorial/#swift","text":"Tip For a comprehensive tutorial with code that you can build and follow along with, see the Tutorials in the repo. This section will be restructured soon to incorporate that and Kotlin tutorials. The Workflow infrastructure is split into several modules.","title":"Swift"},{"location":"tutorial/#workflow","text":"The Workflow library contains the core types that are used to implement state-driven workflows, including the Workflow protocol and related indrastructure.","title":"Workflow"},{"location":"tutorial/#workflowui","text":"Contains the basic infrastructure required to build a Workflow-based application that uses UIKit . Workflow for iOS makes extensive use of ReactiveSwift . If you are new to reactive programming, you may want to familiarize yourself with some of the basics. Workflow takes care of a lot of the reactive plumbing in a typical application, but you will have a better time if you understand what the framework is doing. Core Reactive Primitives Basic Operators How does ReactiveSwift relate to RxSwift?","title":"WorkflowUI"},{"location":"tutorial/#next-steps","text":"Tooling Adding Workflow to a Project Building a Workflow Building a View Controller from a Screen Using a Workflow to Show UI","title":"Next Steps"},{"location":"tutorial/adding-workflow-to-a-project/","text":"Adding Workflow to a project \u00b6 This document will guide you through the process of adding Workflow to an iOS project. Libraries \u00b6 You\u2019ll need the following four libraries: 1 2 3 import Workflow import WorkflowUI import ReactiveSwift The easiest way to integrate these libraries is via Cocoapods. If you are using Cocoapods, you can simply add the dependencies to your .podspec . 1 2 3 4 5 6 7 8 9 10 # MySoftware.podspec Pod :: Spec . new do | s | # ... s . dependency 'Workflow' s . dependency 'WorkflowUI' s . dependency 'ReactiveSwift' # ... end","title":"Adding Workflow to a project"},{"location":"tutorial/adding-workflow-to-a-project/#adding-workflow-to-a-project","text":"This document will guide you through the process of adding Workflow to an iOS project.","title":"Adding Workflow to a project"},{"location":"tutorial/adding-workflow-to-a-project/#libraries","text":"You\u2019ll need the following four libraries: 1 2 3 import Workflow import WorkflowUI import ReactiveSwift The easiest way to integrate these libraries is via Cocoapods. If you are using Cocoapods, you can simply add the dependencies to your .podspec . 1 2 3 4 5 6 7 8 9 10 # MySoftware.podspec Pod :: Spec . new do | s | # ... s . dependency 'Workflow' s . dependency 'WorkflowUI' s . dependency 'ReactiveSwift' # ... end","title":"Libraries"},{"location":"tutorial/building-a-view-controller-from-screen/","text":"Building a View Controller from a Screen \u00b6 Now that we have a workflow, we need a way to map our screen to an actual view controller. ScreenViewController \u00b6 The ScreenViewController provides a base class that hides the plumbing of updating a view controller from a view model update. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 struct DemoScreen : Screen { let title : String let onTap : () -> Void func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription { return DemoScreenViewController . description ( for : self , environment : environment ) } } class DemoScreenViewController : ScreenViewController < DemoScreen > { private let button : UIButton required init ( screen : DemoScreen , environment : ViewEnvironment ) { button = UIButton () super . init ( screen : screen , environment : environment ) update ( screen : screen ) } override func viewDidLoad () { super . viewDidLoad () button . addTarget ( self , action : #selector ( buttonPressed ( sender :)), for : . touchUpInside ) view . addSubview ( button ) } override func viewWillLayoutSubviews () { super . viewWillLayoutSubviews () button . frame = view . bounds } override func screenDidChange ( from previousScreen : DemoScreen , previousEnvironment : ViewEnvironment ) { super . screenDidChange ( from : previousScreen , previousEnvironment : previousEnvironment ) update ( screen : screen ) } private func update ( screen : DemoScreen ) { button . setTitle ( screen . title , for : . normal ) } @objc private func buttonPressed ( sender : UIButton ) { screen . onTap () } } Lifecycle \u00b6 When the view controller is first created, it is given the initial screen value. In the example, we create the button and set the title for it via the update method. The view loads as normal, adding the button the hierarchy and setting up the target:action for the button being pressed. The button is tapped. When the callback is called, we call the onTap closure passed into the screen. The workflow will handle this event, update its state, and a new screen will be rendered. The updated screen is passed to the view controller via the screenDidChange(from previousScreen: previousEnvironment: previousEnvironment:) method. Again, the view controller updates the title of the button based on what was passed in the screen.","title":"Building a View Controller from a Screen"},{"location":"tutorial/building-a-view-controller-from-screen/#building-a-view-controller-from-a-screen","text":"Now that we have a workflow, we need a way to map our screen to an actual view controller.","title":"Building a View Controller from a Screen"},{"location":"tutorial/building-a-view-controller-from-screen/#screenviewcontroller","text":"The ScreenViewController provides a base class that hides the plumbing of updating a view controller from a view model update. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 struct DemoScreen : Screen { let title : String let onTap : () -> Void func viewControllerDescription ( environment : ViewEnvironment ) -> ViewControllerDescription { return DemoScreenViewController . description ( for : self , environment : environment ) } } class DemoScreenViewController : ScreenViewController < DemoScreen > { private let button : UIButton required init ( screen : DemoScreen , environment : ViewEnvironment ) { button = UIButton () super . init ( screen : screen , environment : environment ) update ( screen : screen ) } override func viewDidLoad () { super . viewDidLoad () button . addTarget ( self , action : #selector ( buttonPressed ( sender :)), for : . touchUpInside ) view . addSubview ( button ) } override func viewWillLayoutSubviews () { super . viewWillLayoutSubviews () button . frame = view . bounds } override func screenDidChange ( from previousScreen : DemoScreen , previousEnvironment : ViewEnvironment ) { super . screenDidChange ( from : previousScreen , previousEnvironment : previousEnvironment ) update ( screen : screen ) } private func update ( screen : DemoScreen ) { button . setTitle ( screen . title , for : . normal ) } @objc private func buttonPressed ( sender : UIButton ) { screen . onTap () } }","title":"ScreenViewController"},{"location":"tutorial/building-a-view-controller-from-screen/#lifecycle","text":"When the view controller is first created, it is given the initial screen value. In the example, we create the button and set the title for it via the update method. The view loads as normal, adding the button the hierarchy and setting up the target:action for the button being pressed. The button is tapped. When the callback is called, we call the onTap closure passed into the screen. The workflow will handle this event, update its state, and a new screen will be rendered. The updated screen is passed to the view controller via the screenDidChange(from previousScreen: previousEnvironment: previousEnvironment:) method. Again, the view controller updates the title of the button based on what was passed in the screen.","title":"Lifecycle"},{"location":"tutorial/building-a-workflow/","text":"Building a Workflow \u00b6 Introduction \u00b6 A simple workflow looks something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 struct DemoWorkflow : Workflow { var name : String init ( name : String ) { self . name = name } } extension DemoWorkflow { struct State {} func makeInitialState () -> State { return State () } func workflowDidChange ( from previousWorkflow : DemoWorkflow , state : inout State ) { } func render ( state : State , context : RenderContext < DemoWorkflow >) -> String { return \"Hello, \\( name ) \" } } A type conforming to Workflow represents a single node in the workflow tree. It should contain any values that must be provided by its parent (who is generally responsible for creating child workflows). Configuration parameters, strings, network services\u2026 If your workflow needs access to a value or object that it cannot create itself, they should be passed into the workflow\u2019s initializer. Every workflow defines its own State type to contain any data that should persist through subsequent render passes. Render \u00b6 Workflows are only useful when they render a value for use by their parent (or, if they are the root workflow, for display). This type is very commonly a view model, or Screen . The render(state:context:) method has a couple of parameters, so we\u2019ll work through them one by one. 1 func render ( state : State , context : RenderContext < DemoWorkflow >) -> Rendering state \u00b6 Contains a value of type State to provide access to the current state. Any time the state of workflow changes, render is called again to take into account the change in state. context \u00b6 The render context: provides a way for a workflow to defer to nested (child) workflows to generate some or all of its rendered output. We\u2019ll walk through that process later on when we cover composition. allows a workflow to request the execution of asynchronous tasks ( Worker s) generates event handlers for use in constructing view models. In order for us to see the anything in our app, we\u2019ll need to return a Screen that can be turned into a view controller: 1 2 3 func render ( state : State , context : RenderContext < DemoWorkflow >) -> DemoScreen { return DemoScreen ( title : \"A nice title\" ) } Actions, or \u201cThings that advance a workflow\u201d \u00b6 So far we have only covered workflows that perform simple tasks like generate strings or simple screens with no actions. If our workflows take on a complicated roles like generating view models, however, they will inevitably be required to handle events of some kind \u2013 some from UI events such as button taps, others from infrastructure events such as network responses. In conventional UIKit code, it is common to deal with each of those event types differently. The common pattern is to implement a method like handleButtonTap(sender:) . Workflows are more strict about events, however. Workflows require that all events be expressed as \u201cWorkflow Actions.\u201d These actions should be thought of as the entry point to your workflow. If any action of any kind happens (that your workflow cares about), it should be modeled as an action. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct DemoWorkflow : Workflow { /// ... } enum Action : WorkflowAction { typealias WorkflowType = DemoWorkflow case refreshButtonTapped /// UI event case refreshRequestFinished ( RefreshResponse ) /// Network event func apply ( toState state : inout DemoWorkflow . State ) -> DemoWorkflow . Output ? { /// ... } } The Update Cycle \u00b6 Every time a new action is received, it is applied to the current state of the workflow. If your workflow does more than simply render values, the action\u2019s apply is the method where the logic lives. There are two things that the apply(toState:) method is responsible for: Transitioning state (Optionally) emitting an output event Note that the render(state:context:) method is called after every state change, so you can be sure that any state changes will be reflected. Since we have a way of expressing an event from our UI, we can now use the callback on our view model to send that event back to the workflow: 1 2 3 4 5 6 7 8 func render ( state : State , context : RenderContext < DemoWorkflow >) -> DemoScreen { // Create a sink of our Action type so we can send actions back to the workflow. let sink = context . makeSink ( of : Action . self ) return DemoScreen ( title : \"A nice title\" , onTap : { sink . send ( Action . refreshButtonTapped ) } } State \u00b6 Some workflows do not need state at all \u2013 they simply render values based on the values they were initialized with. But for more complicated workflows, state management is critical. For example, a multi-screen flow only functions if we are able to define all of the possible steps (model the state), remember which one we are currently on (persist state), and move to other steps in the future (transition state). To define your workflow\u2019s state, simply implement the associatedtype State via an enum or struct. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct WelcomeFlowWorkflow : Workflow { enum State { case splashScreen case loginFlow case signupFlow } enum Action : WorkflowAction { case back /// ... } /// ... } Note Workflows (and their State ) should always be implemented through value types (structs and enums) due to the way the framework handles state changes. This means that you can never capture references to self , but the consistent flow of data pays dividends \u2013 try this architecture for a while and we are confident that you will see the benefits. Workers, or \u201cAsynchronous work the workflow needs done\u201d \u00b6 A workflow may need to do some amount of asynchronous work (such as a network request, reading from a sqlite database, etc). Workers provide a declarative interface to units of asynchronous work. To do something asynchronously, we define a worker that has an Output type and defines a run method that that returns a Reactive Swift SignalProducer . When this worker will be run, the SignalProducer is subscribed to starting the async task. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 struct RefreshWorker : Worker { enum Output { case success ( String ) case error ( Error ) } func run () -> SignalProducer < RefreshWorker . Output , Never > { return SignalProducer ( value : . success ( \"We did it!\" )) . delay ( 1.0 , on : QueueScheduler . main ) } func isEquivalent ( to otherWorker : RefreshWorker ) -> Bool { return true } } Because a Worker is a declarative representation of work, it also needs to define an isEquivalent to guarantee that we are not running more than one at the same time. For the simple example above, it is always considered equivalent as we want only one of this type of worker running at a time. In order to start asynchronous work, the workflow requests it in the render method, looking something like: 1 2 3 4 5 6 7 8 9 10 11 12 public func render ( state : State , context : RenderContext < DemoWorkflow >) -> DemoScreen { context . awaitResult ( for : RefreshWorker ()) { output -> Action in switch output { case . success ( let result ): return Action . refreshComplete ( result ) case . error ( let error ): return Action . refreshError ( error ) } } } When the context is told to await a result from a worker, the context will do the following: Check if there is already a worker running of the same type: If there is not, or isEquivalent is false, call run on the worker and subscribe to the SignalProducer If there is already a worker running and isEquivalent is true, continue to wait for it to produce an output. When the SignalProducer from the Worker returns an output, it is mapped to an Action and handled the same way as any other action. Output Events \u00b6 The last role of the update cycle is to emit output events. As workflows form a hierarchy, it is common for children to send events up the tree. This may happen when a child workflow finishes or cancels, for example. Workflows can define an output type, which may then be returned by Actions. Composition \u00b6 Composition is the primary tool that we can use to manage complexity in a growing application. Workflows should always be kept small enough to be understandable \u2013 less than 150 lines is a good target. By composing together multiple workflows, complex problems can be broken down into individual pieces that can be quickly understood by other developers (including future you). The context provided to the render(state:context:) method defines the API through which composition is made possible. The Render Context \u00b6 The useful role of children is ultimately to provide rendered values (typically screen models) via their render(state:context:) implementation. To obtain that value from a child workflow, the rendered(with context:key:) method is invoked on the child workflow. When a workflow is rendered with the context, the context will do the following: Check if the child workflow is new or existing: If a workflow with the same type was used during the last render pass, the existing child workflow will be updated with the new workflow. Otherwise, a new child workflow node will be initialized. The child workflow\u2019s render(state:context:) method is called. The rendered value is returned. In practice, this looks something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 struct ParentWorkflow : Workflow { func render ( state : State , context : RenderContext < ParentWorkflow >) -> String { let childWorkflow = ChildWorkflow ( text : \"Hello, World\" ) return childWorkflow . rendered ( with : context ) } } struct ChildWorkflow : Workflow { var text : String // ... func render ( state : State , context : RenderContext < ChildWorkflow >) -> String { return String ( text . reversed ()) } }","title":"Building a Workflow"},{"location":"tutorial/building-a-workflow/#building-a-workflow","text":"","title":"Building a Workflow"},{"location":"tutorial/building-a-workflow/#introduction","text":"A simple workflow looks something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 struct DemoWorkflow : Workflow { var name : String init ( name : String ) { self . name = name } } extension DemoWorkflow { struct State {} func makeInitialState () -> State { return State () } func workflowDidChange ( from previousWorkflow : DemoWorkflow , state : inout State ) { } func render ( state : State , context : RenderContext < DemoWorkflow >) -> String { return \"Hello, \\( name ) \" } } A type conforming to Workflow represents a single node in the workflow tree. It should contain any values that must be provided by its parent (who is generally responsible for creating child workflows). Configuration parameters, strings, network services\u2026 If your workflow needs access to a value or object that it cannot create itself, they should be passed into the workflow\u2019s initializer. Every workflow defines its own State type to contain any data that should persist through subsequent render passes.","title":"Introduction"},{"location":"tutorial/building-a-workflow/#render","text":"Workflows are only useful when they render a value for use by their parent (or, if they are the root workflow, for display). This type is very commonly a view model, or Screen . The render(state:context:) method has a couple of parameters, so we\u2019ll work through them one by one. 1 func render ( state : State , context : RenderContext < DemoWorkflow >) -> Rendering","title":"Render"},{"location":"tutorial/building-a-workflow/#state","text":"Contains a value of type State to provide access to the current state. Any time the state of workflow changes, render is called again to take into account the change in state.","title":"state"},{"location":"tutorial/building-a-workflow/#context","text":"The render context: provides a way for a workflow to defer to nested (child) workflows to generate some or all of its rendered output. We\u2019ll walk through that process later on when we cover composition. allows a workflow to request the execution of asynchronous tasks ( Worker s) generates event handlers for use in constructing view models. In order for us to see the anything in our app, we\u2019ll need to return a Screen that can be turned into a view controller: 1 2 3 func render ( state : State , context : RenderContext < DemoWorkflow >) -> DemoScreen { return DemoScreen ( title : \"A nice title\" ) }","title":"context"},{"location":"tutorial/building-a-workflow/#actions-or-things-that-advance-a-workflow","text":"So far we have only covered workflows that perform simple tasks like generate strings or simple screens with no actions. If our workflows take on a complicated roles like generating view models, however, they will inevitably be required to handle events of some kind \u2013 some from UI events such as button taps, others from infrastructure events such as network responses. In conventional UIKit code, it is common to deal with each of those event types differently. The common pattern is to implement a method like handleButtonTap(sender:) . Workflows are more strict about events, however. Workflows require that all events be expressed as \u201cWorkflow Actions.\u201d These actions should be thought of as the entry point to your workflow. If any action of any kind happens (that your workflow cares about), it should be modeled as an action. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct DemoWorkflow : Workflow { /// ... } enum Action : WorkflowAction { typealias WorkflowType = DemoWorkflow case refreshButtonTapped /// UI event case refreshRequestFinished ( RefreshResponse ) /// Network event func apply ( toState state : inout DemoWorkflow . State ) -> DemoWorkflow . Output ? { /// ... } }","title":"Actions, or \u201cThings that advance a workflow\u201d"},{"location":"tutorial/building-a-workflow/#the-update-cycle","text":"Every time a new action is received, it is applied to the current state of the workflow. If your workflow does more than simply render values, the action\u2019s apply is the method where the logic lives. There are two things that the apply(toState:) method is responsible for: Transitioning state (Optionally) emitting an output event Note that the render(state:context:) method is called after every state change, so you can be sure that any state changes will be reflected. Since we have a way of expressing an event from our UI, we can now use the callback on our view model to send that event back to the workflow: 1 2 3 4 5 6 7 8 func render ( state : State , context : RenderContext < DemoWorkflow >) -> DemoScreen { // Create a sink of our Action type so we can send actions back to the workflow. let sink = context . makeSink ( of : Action . self ) return DemoScreen ( title : \"A nice title\" , onTap : { sink . send ( Action . refreshButtonTapped ) } }","title":"The Update Cycle"},{"location":"tutorial/building-a-workflow/#state_1","text":"Some workflows do not need state at all \u2013 they simply render values based on the values they were initialized with. But for more complicated workflows, state management is critical. For example, a multi-screen flow only functions if we are able to define all of the possible steps (model the state), remember which one we are currently on (persist state), and move to other steps in the future (transition state). To define your workflow\u2019s state, simply implement the associatedtype State via an enum or struct. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct WelcomeFlowWorkflow : Workflow { enum State { case splashScreen case loginFlow case signupFlow } enum Action : WorkflowAction { case back /// ... } /// ... } Note Workflows (and their State ) should always be implemented through value types (structs and enums) due to the way the framework handles state changes. This means that you can never capture references to self , but the consistent flow of data pays dividends \u2013 try this architecture for a while and we are confident that you will see the benefits.","title":"State"},{"location":"tutorial/building-a-workflow/#workers-or-asynchronous-work-the-workflow-needs-done","text":"A workflow may need to do some amount of asynchronous work (such as a network request, reading from a sqlite database, etc). Workers provide a declarative interface to units of asynchronous work. To do something asynchronously, we define a worker that has an Output type and defines a run method that that returns a Reactive Swift SignalProducer . When this worker will be run, the SignalProducer is subscribed to starting the async task. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 struct RefreshWorker : Worker { enum Output { case success ( String ) case error ( Error ) } func run () -> SignalProducer < RefreshWorker . Output , Never > { return SignalProducer ( value : . success ( \"We did it!\" )) . delay ( 1.0 , on : QueueScheduler . main ) } func isEquivalent ( to otherWorker : RefreshWorker ) -> Bool { return true } } Because a Worker is a declarative representation of work, it also needs to define an isEquivalent to guarantee that we are not running more than one at the same time. For the simple example above, it is always considered equivalent as we want only one of this type of worker running at a time. In order to start asynchronous work, the workflow requests it in the render method, looking something like: 1 2 3 4 5 6 7 8 9 10 11 12 public func render ( state : State , context : RenderContext < DemoWorkflow >) -> DemoScreen { context . awaitResult ( for : RefreshWorker ()) { output -> Action in switch output { case . success ( let result ): return Action . refreshComplete ( result ) case . error ( let error ): return Action . refreshError ( error ) } } } When the context is told to await a result from a worker, the context will do the following: Check if there is already a worker running of the same type: If there is not, or isEquivalent is false, call run on the worker and subscribe to the SignalProducer If there is already a worker running and isEquivalent is true, continue to wait for it to produce an output. When the SignalProducer from the Worker returns an output, it is mapped to an Action and handled the same way as any other action.","title":"Workers, or \"Asynchronous work the workflow needs done\""},{"location":"tutorial/building-a-workflow/#output-events","text":"The last role of the update cycle is to emit output events. As workflows form a hierarchy, it is common for children to send events up the tree. This may happen when a child workflow finishes or cancels, for example. Workflows can define an output type, which may then be returned by Actions.","title":"Output Events"},{"location":"tutorial/building-a-workflow/#composition","text":"Composition is the primary tool that we can use to manage complexity in a growing application. Workflows should always be kept small enough to be understandable \u2013 less than 150 lines is a good target. By composing together multiple workflows, complex problems can be broken down into individual pieces that can be quickly understood by other developers (including future you). The context provided to the render(state:context:) method defines the API through which composition is made possible.","title":"Composition"},{"location":"tutorial/building-a-workflow/#the-render-context","text":"The useful role of children is ultimately to provide rendered values (typically screen models) via their render(state:context:) implementation. To obtain that value from a child workflow, the rendered(with context:key:) method is invoked on the child workflow. When a workflow is rendered with the context, the context will do the following: Check if the child workflow is new or existing: If a workflow with the same type was used during the last render pass, the existing child workflow will be updated with the new workflow. Otherwise, a new child workflow node will be initialized. The child workflow\u2019s render(state:context:) method is called. The rendered value is returned. In practice, this looks something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 struct ParentWorkflow : Workflow { func render ( state : State , context : RenderContext < ParentWorkflow >) -> String { let childWorkflow = ChildWorkflow ( text : \"Hello, World\" ) return childWorkflow . rendered ( with : context ) } } struct ChildWorkflow : Workflow { var text : String // ... func render ( state : State , context : RenderContext < ChildWorkflow >) -> String { return String ( text . reversed ()) } }","title":"The Render Context"},{"location":"tutorial/tooling/","text":"Tooling \u00b6 Xcode templates \u00b6 Workflow comes with a set of file templates to simplify the process of building features. After installation, these templates can be found via File > New > New File... in Xcode. Launch terminal and navigate to the Workflow source directory. Run ./Tooling/Templates/install-xcode-templates.sh . Restart Xcode.","title":"Tooling"},{"location":"tutorial/tooling/#tooling","text":"","title":"Tooling"},{"location":"tutorial/tooling/#xcode-templates","text":"Workflow comes with a set of file templates to simplify the process of building features. After installation, these templates can be found via File > New > New File... in Xcode. Launch terminal and navigate to the Workflow source directory. Run ./Tooling/Templates/install-xcode-templates.sh . Restart Xcode.","title":"Xcode templates"},{"location":"tutorial/using-a-workflow-for-ui/","text":"Using a workflow to show UI \u00b6 ContainerViewController \u00b6 In the Workflow architecture, the container acts as the glue between the state-driven world of Workflows and the UI that is ultimately displayed. On iOS, the container is implemented as ContainerViewController . 1 2 3 4 5 6 7 8 /// Drives view controllers from a root Workflow. public final class ContainerViewController < Output , ScreenType >: UIViewController where ScreenType : Screen { /// Emits output events from the bound workflow. public let output : Signal < Output , Never > public convenience init < W : Workflow >( workflow : W ) where W . Rendering == ScreenType , W . Output == Output } The initializer argument is the workflow that will drive your application. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import UIKit import Workflow import WorkflowUI @UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate { var window : UIWindow ? func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplication . LaunchOptionsKey : Any ]?) -> Bool { let window = UIWindow ( frame : UIScreen . main . bounds ) let container = ContainerViewController ( workflow : DemoWorkflow () ) window . rootViewController = container self . window = window window . makeKeyAndVisible () return true } } Now, when the ContainerViewController is shown, it will start the workflow and render will be called returning the DemoScreen . The container will use viewControllerDescription to build a DemoScreenViewController and add it to the view hierarchy to display.","title":"Using a Workflow to Show UI"},{"location":"tutorial/using-a-workflow-for-ui/#using-a-workflow-to-show-ui","text":"","title":"Using a workflow to show UI"},{"location":"tutorial/using-a-workflow-for-ui/#containerviewcontroller","text":"In the Workflow architecture, the container acts as the glue between the state-driven world of Workflows and the UI that is ultimately displayed. On iOS, the container is implemented as ContainerViewController . 1 2 3 4 5 6 7 8 /// Drives view controllers from a root Workflow. public final class ContainerViewController < Output , ScreenType >: UIViewController where ScreenType : Screen { /// Emits output events from the bound workflow. public let output : Signal < Output , Never > public convenience init < W : Workflow >( workflow : W ) where W . Rendering == ScreenType , W . Output == Output } The initializer argument is the workflow that will drive your application. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import UIKit import Workflow import WorkflowUI @UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate { var window : UIWindow ? func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplication . LaunchOptionsKey : Any ]?) -> Bool { let window = UIWindow ( frame : UIScreen . main . bounds ) let container = ContainerViewController ( workflow : DemoWorkflow () ) window . rootViewController = container self . window = window window . makeKeyAndVisible () return true } } Now, when the ContainerViewController is shown, it will start the workflow and render will be called returning the DemoScreen . The container will use viewControllerDescription to build a DemoScreenViewController and add it to the view hierarchy to display.","title":"ContainerViewController"},{"location":"userguide/comparison/","text":"Comparison with other frameworks \u00b6 Coming soon!","title":"Comparison with other frameworks"},{"location":"userguide/comparison/#comparison-with-other-frameworks","text":"Coming soon!","title":"Comparison with other frameworks"},{"location":"userguide/concepts/","text":"Core Concepts \u00b6 Architectural Concepts \u00b6 Unidirectional Data Flow \u00b6 There is a wealth of information on the web about Unidirectional Data Flow , but it very simply means that there is a single path along which data travel from your business logic to your UI, and events travel to your business logic from your UI, and they always and only travel in one direction along that path. For Workflow, this also implies that the UI is (almost) stateless, and that the interesting state for your app is centralized and not duplicated. In practice, this makes program flow much easier to reason about because anytime something happens in an app, it removes the questions of where the state came from that caused it, which components got which events, and which sequences of cause and effect actually occurred. It makes unit testing easier because state and events are explicit, and always live in the same place and flow through the same APIs, so unit tests only need to test state transitions, for the most part. Declarative vs Imperative \u00b6 Traditionally, most mobile code is \u201cimperative\u201d \u2013 it consists of instructions for how to build and display the UI. These instructions can include control flow like loops. Imperative code is usually stateful, state is usually sprinkled all over the place, and tends to care about instances and identity. When reading imperative code, you almost have to run an interpreter and keep all the pieces of state in your head to figure out what it does. Web UI is traditionally declarative \u2013 it describes what to render, and some aspects of how to render it (style), but doesn\u2019t say how to actually draw it. Declarative code is usually easier to read than imperative code. It describes what it produces, not how to generate it. Declarative code usually cares more about pure values than instance identities. However, since computers still need actual instructions at some point, declarative code requires something else, usually imperative, either a compiler or interpreter, to actually do something with it. Workflow code is written in regular Kotlin or Swift, which are both imperative languages, but the library encourages you to write your logic in a declarative and functional style. The library manages state and wiring up event handling for you, so the only code you need to write is code that is actually interesting for your particular problem. A note about functional programming \u00b6 Kotlin and Swift are not strictly functional programming languages, but both have features that allow you to write functional -style code. Functional code discourages side effects and is generally much easier to test than object-oriented code. Functional and declarative programming go very well together, and Workflow encourages you to write such code. Core Components \u00b6 Workflows \u00b6 The Workflows at the left of the diagram contain all state and business logic for the application. This is where network requests happen, navigation decisions are made, models are saved to or loaded from disk \u2013 if it\u2019s not UI, it\u2019s in this box. For more information, see Workflow Core Concepts . View Models \u00b6 The primary job of the Workflows is to emit an observable stream of view models representing the current state of the application\u2019s UI. You will sometimes hear these view models referred to as \u2018screens\u2019, which is just another way to refer to a view model that contains the data for an entire screen in the app. For more information, see Workflow UI Concepts . Container \u00b6 The container is responsible for plumbing together the two separate halves of the application. It subscribes to the stream of view models that the workflows provide, then implements the logic to update the live UI whenever a new view model is emitted. For more information, see Workflow UI Concepts . UI \u00b6 This is typically conventional platform-specific UI code. One important note is that UI code should never attempt to navigate using system components (navigation controller pushes, modal presentation, etc). In this architecture the workflows are in charge \u2013 any navigation that happens outside of the workflow will be disregarded and stomped on during the next update cycle. For more information, see Workflow UI Concepts . Events \u00b6 In order for the application to actually do anything, the workflow needs to receive events from the UI. When the user interacts with the application by, for example, tapping a button, the workflow receives that event \u2013 which may trigger a simple state transition, or more complex behavior such as a network request. For more information, see Workflow Core Concepts . Info While the core shape of the libraries is shared by Swift and Kotlin implementations, some of the naming and types differ slightly to accommodate each language\u2019s particular type system and naming conventions. Where those differences occur in this document, they are noted in \u201cSwift vs Kotlin\u201d blurbs. See Where Swift and Kotlin Libraries Differ for an overall summary. In general, any time a generic type is referred to as Foo , in source code the Swift associated type is called Foo and the Kotlin type parameter is called FooT .","title":"Core Concepts"},{"location":"userguide/concepts/#core-concepts","text":"","title":"Core Concepts"},{"location":"userguide/concepts/#architectural-concepts","text":"","title":"Architectural Concepts"},{"location":"userguide/concepts/#unidirectional-data-flow","text":"There is a wealth of information on the web about Unidirectional Data Flow , but it very simply means that there is a single path along which data travel from your business logic to your UI, and events travel to your business logic from your UI, and they always and only travel in one direction along that path. For Workflow, this also implies that the UI is (almost) stateless, and that the interesting state for your app is centralized and not duplicated. In practice, this makes program flow much easier to reason about because anytime something happens in an app, it removes the questions of where the state came from that caused it, which components got which events, and which sequences of cause and effect actually occurred. It makes unit testing easier because state and events are explicit, and always live in the same place and flow through the same APIs, so unit tests only need to test state transitions, for the most part.","title":"Unidirectional Data Flow"},{"location":"userguide/concepts/#declarative-vs-imperative","text":"Traditionally, most mobile code is \u201cimperative\u201d \u2013 it consists of instructions for how to build and display the UI. These instructions can include control flow like loops. Imperative code is usually stateful, state is usually sprinkled all over the place, and tends to care about instances and identity. When reading imperative code, you almost have to run an interpreter and keep all the pieces of state in your head to figure out what it does. Web UI is traditionally declarative \u2013 it describes what to render, and some aspects of how to render it (style), but doesn\u2019t say how to actually draw it. Declarative code is usually easier to read than imperative code. It describes what it produces, not how to generate it. Declarative code usually cares more about pure values than instance identities. However, since computers still need actual instructions at some point, declarative code requires something else, usually imperative, either a compiler or interpreter, to actually do something with it. Workflow code is written in regular Kotlin or Swift, which are both imperative languages, but the library encourages you to write your logic in a declarative and functional style. The library manages state and wiring up event handling for you, so the only code you need to write is code that is actually interesting for your particular problem.","title":"Declarative vs Imperative"},{"location":"userguide/concepts/#a-note-about-functional-programming","text":"Kotlin and Swift are not strictly functional programming languages, but both have features that allow you to write functional -style code. Functional code discourages side effects and is generally much easier to test than object-oriented code. Functional and declarative programming go very well together, and Workflow encourages you to write such code.","title":"A note about functional programming"},{"location":"userguide/concepts/#core-components","text":"","title":"Core Components"},{"location":"userguide/concepts/#workflows","text":"The Workflows at the left of the diagram contain all state and business logic for the application. This is where network requests happen, navigation decisions are made, models are saved to or loaded from disk \u2013 if it\u2019s not UI, it\u2019s in this box. For more information, see Workflow Core Concepts .","title":"Workflows"},{"location":"userguide/concepts/#view-models","text":"The primary job of the Workflows is to emit an observable stream of view models representing the current state of the application\u2019s UI. You will sometimes hear these view models referred to as \u2018screens\u2019, which is just another way to refer to a view model that contains the data for an entire screen in the app. For more information, see Workflow UI Concepts .","title":"View Models"},{"location":"userguide/concepts/#container","text":"The container is responsible for plumbing together the two separate halves of the application. It subscribes to the stream of view models that the workflows provide, then implements the logic to update the live UI whenever a new view model is emitted. For more information, see Workflow UI Concepts .","title":"Container"},{"location":"userguide/concepts/#ui","text":"This is typically conventional platform-specific UI code. One important note is that UI code should never attempt to navigate using system components (navigation controller pushes, modal presentation, etc). In this architecture the workflows are in charge \u2013 any navigation that happens outside of the workflow will be disregarded and stomped on during the next update cycle. For more information, see Workflow UI Concepts .","title":"UI"},{"location":"userguide/concepts/#events","text":"In order for the application to actually do anything, the workflow needs to receive events from the UI. When the user interacts with the application by, for example, tapping a button, the workflow receives that event \u2013 which may trigger a simple state transition, or more complex behavior such as a network request. For more information, see Workflow Core Concepts . Info While the core shape of the libraries is shared by Swift and Kotlin implementations, some of the naming and types differ slightly to accommodate each language\u2019s particular type system and naming conventions. Where those differences occur in this document, they are noted in \u201cSwift vs Kotlin\u201d blurbs. See Where Swift and Kotlin Libraries Differ for an overall summary. In general, any time a generic type is referred to as Foo , in source code the Swift associated type is called Foo and the Kotlin type parameter is called FooT .","title":"Events"},{"location":"userguide/core-patterns/","text":"Workflow Core: Patterns/Variations \u00b6 There are a lot associated/generic types in workflow code \u2013 that doesn\u2019t mean you always need to use all of them. Here are some common configurations we\u2019ve seen. Stateless Workflows \u00b6 Remember that workflow state is made up of public and private parts. When a workflow\u2019s state consists entirely of public state (i.e. it\u2019s initializer arguments in Swift or PropsT in Kotlin), it can ignore all the machinery for private state. In Swift, the State type can be Void , and in Kotlin it can be Unit \u2013 such workflows are often referred to as \u201cstateless\u201d, since they have no state of their own. Props-less Workflows \u00b6 Some workflows manage all of their state internally, and have no public state (aka props). In Swift, this just means the workflow implementation has no parameters (although this is rare, see Injecting Dependencies below). In Kotlin, the PropsT type can be Unit . RenderContext has convenience overloads of most of its functions to implicitly pass Unit for these workflows. Outputless Workflows \u00b6 Workflows that only talk to their parent via their Rendering , and never emit any output, are encouraged to indicate that by using the bottom type as their Output type. In addition to documenting the fact that the workflow will never output, using the bottom type also lets the compiler enforce it \u2013 code that tries to emit outputs will not compile. In Swift, the Output type is specified as Never . In Kotlin, use Nothing . Composite Workflows \u00b6 Composition is a powerful tool for working with Workflows. A workflow can often accomplish a lot simply by rendering various children. It may just combine the renderings of multiple children, or use its props to determine which of a set of children to render. Such workflows can often be stateless. Props values v. Injected Dependencies \u00b6 Dependency injection is a technique for making code less coupled and more testable. In short, it\u2019s better for classes/structs to accept their dependencies when they\u2019re created instead of hard-coding them. Workflows typically have dependencies like specific Workers they need to perform some tasks, child workflows to delegate rendering to, or helpers for things like network requests, formatting and logging. Swift \u00b6 A Swift workflow typically receives its dependencies as initializer arguments, just like its input values, and is normally instantiated anew by its parent in each call to the parent\u2019s render method. The factory pattern can be employed to keep knowledge of children\u2019s implementation details from leaking into their parents. Kotlin \u00b6 Kotlin workflows make a more formal distinction between dependencies and props, via the PropsT parameter type on the Kotlin Workflow interface. Dependencies (e.g. a network service) are typically provided as constructor parameters, while props values (e.g. a record locator) are provided by the parent as an argument to the RenderContext.renderChild method. This works seamlessly with DI libraries like Dagger . The careful reader will note that this is technically storing \u201cstate\u201d in the workflow instance \u2013 something that is generally discouraged. However, since this \u201cstate\u201d is never changed, we can make an exception for this case. If a workflow has properties, they should only be used to store injected dependencies or dependencies derived from injected ones (e.g. Worker s created from Observable s). Info This difference between Swift and Kotlin practices is a side effect of Kotlin\u2019s lack of a parallel to Swift\u2019s Self type. Kotlin has no practical way to provide a method like Swift\u2019s Workflow.workflowDidChange , which accepts a strongly typed reference to the instance from the previous run of a parent\u2019s Render method. Kotlin\u2019s alternative, StatefulWorkflow.onPropsChanged , requires the extra PropsT type parameter.","title":"Patterns"},{"location":"userguide/core-patterns/#workflow-core-patternsvariations","text":"There are a lot associated/generic types in workflow code \u2013 that doesn\u2019t mean you always need to use all of them. Here are some common configurations we\u2019ve seen.","title":"Workflow Core: Patterns/Variations"},{"location":"userguide/core-patterns/#stateless-workflows","text":"Remember that workflow state is made up of public and private parts. When a workflow\u2019s state consists entirely of public state (i.e. it\u2019s initializer arguments in Swift or PropsT in Kotlin), it can ignore all the machinery for private state. In Swift, the State type can be Void , and in Kotlin it can be Unit \u2013 such workflows are often referred to as \u201cstateless\u201d, since they have no state of their own.","title":"Stateless Workflows"},{"location":"userguide/core-patterns/#props-less-workflows","text":"Some workflows manage all of their state internally, and have no public state (aka props). In Swift, this just means the workflow implementation has no parameters (although this is rare, see Injecting Dependencies below). In Kotlin, the PropsT type can be Unit . RenderContext has convenience overloads of most of its functions to implicitly pass Unit for these workflows.","title":"Props-less Workflows"},{"location":"userguide/core-patterns/#outputless-workflows","text":"Workflows that only talk to their parent via their Rendering , and never emit any output, are encouraged to indicate that by using the bottom type as their Output type. In addition to documenting the fact that the workflow will never output, using the bottom type also lets the compiler enforce it \u2013 code that tries to emit outputs will not compile. In Swift, the Output type is specified as Never . In Kotlin, use Nothing .","title":"Outputless Workflows"},{"location":"userguide/core-patterns/#composite-workflows","text":"Composition is a powerful tool for working with Workflows. A workflow can often accomplish a lot simply by rendering various children. It may just combine the renderings of multiple children, or use its props to determine which of a set of children to render. Such workflows can often be stateless.","title":"Composite Workflows"},{"location":"userguide/core-patterns/#props-values-v-injected-dependencies","text":"Dependency injection is a technique for making code less coupled and more testable. In short, it\u2019s better for classes/structs to accept their dependencies when they\u2019re created instead of hard-coding them. Workflows typically have dependencies like specific Workers they need to perform some tasks, child workflows to delegate rendering to, or helpers for things like network requests, formatting and logging.","title":"Props values v. Injected Dependencies"},{"location":"userguide/core-patterns/#swift","text":"A Swift workflow typically receives its dependencies as initializer arguments, just like its input values, and is normally instantiated anew by its parent in each call to the parent\u2019s render method. The factory pattern can be employed to keep knowledge of children\u2019s implementation details from leaking into their parents.","title":"Swift"},{"location":"userguide/core-patterns/#kotlin","text":"Kotlin workflows make a more formal distinction between dependencies and props, via the PropsT parameter type on the Kotlin Workflow interface. Dependencies (e.g. a network service) are typically provided as constructor parameters, while props values (e.g. a record locator) are provided by the parent as an argument to the RenderContext.renderChild method. This works seamlessly with DI libraries like Dagger . The careful reader will note that this is technically storing \u201cstate\u201d in the workflow instance \u2013 something that is generally discouraged. However, since this \u201cstate\u201d is never changed, we can make an exception for this case. If a workflow has properties, they should only be used to store injected dependencies or dependencies derived from injected ones (e.g. Worker s created from Observable s). Info This difference between Swift and Kotlin practices is a side effect of Kotlin\u2019s lack of a parallel to Swift\u2019s Self type. Kotlin has no practical way to provide a method like Swift\u2019s Workflow.workflowDidChange , which accepts a strongly typed reference to the instance from the previous run of a parent\u2019s Render method. Kotlin\u2019s alternative, StatefulWorkflow.onPropsChanged , requires the extra PropsT type parameter.","title":"Kotlin"},{"location":"userguide/core-worker/","text":"Workflow Core: Worker \u00b6 The Role of a Worker \u00b6 Worker is a protocol (in Swift) and interface (in Kotlin) that defines an asynchronous task that can be performed by a Workflow . Worker s only emit outputs, they do not have a Rendering type. They are similar to child workflows with Void / Unit rendering types. A workflow can ask the infrastructure to await the result of a worker by passing that worker to the RenderContext.runningWorker method within a call to the render method. A workflow can handle outputs from a Worker . Workers provide a declarative window into the imperative world \u00b6 As nice as it is to write declarative code, real apps need to interact with imperative APIs. Workers allow wrapping imperative APIs so that Workflows can interact with them in a declarative fashion. Instead of making imperative \u201cstart this, do that, now stop\u201d calls, a Workflow can say \u201cI declare that this task should now be running\u201d and let the infrastructure worry about ensuring the task is actually started when necessary, continues running if it was already in flight, and torn down when it\u2019s not needed anymore. Workers can perform side effects \u00b6 Unlike workflows\u2019 render method, which can be called many times and must be idempotent, workers are started and then ran until completion (or cancellation) \u2013 independently of how many times the workflow running them is actually rendered. This means that side effects that should be performed only once when a workflow enters a particular state, for example, should be placed into a Worker that the workflow runs while in that state. Workers are cold reactive streams \u00b6 Workers are effectively simple wrappers around asynchronous streams with explicit equivalence. In Swift, workers are backed by ReactiveSwift SignalProducer s . In Kotlin, they\u2019re backed by Kotlin Flow s . They are also easily derived from Reactive Streams Publishers , including RxJava Observable , Flowable , or Single instances. Worker subscriptions are managed automatically \u00b6 While Workers are backed by reactive streams with library-specific subscription APIs, you never actually subscribe directly to a worker yourself. Instead, a Workflow asks the infrastructure to run a worker, and the infrastructure will take care of initializing and tearing down the subscription as appropriate \u2013 much like how child workflows\u2019 lifetimes are automatically managed by the runtime. This makes it impossible to accidentally leak a subscription to a worker. Workers manage their own internal state \u00b6 Unlike Workflows, which are effectively collections of functions defining state transitions, Workers represent long-running tasks. For example, Workers commonly execute network requests. The worker\u2019s stream will open a socket and, either blocking on a background thread or asynchronously, read from that socket and eventually emit data to the workflow that is running it. Workers define their own equivalence \u00b6 Since Workers represent ongoing tasks, the infrastructure needs to be able to tell when two workers represent the same task (so it doesn\u2019t perform the task twice), or when a worker has changed between render passes such that it needs to be torn down and re-started for the new work. For these reasons, any time a workflow requests that a worker be run in sequential render passes, it is asked to compare itself with its last instance and determine if they are equivalent. In Swift, this is determined by the Worker isEquivalent:to: method. Worker s that conform to Equatable will automatically get an isEquivalent:to: method based on the Equatable implementation. In Kotlin, the Worker interface defines the doesSameWorkAs method which is passed the previous worker. Kotlin: Why don\u2019t Workers use equals ? Worker equivalence is a key part of the Worker API. The default implementation of equals , which just compares object identity, is almost always incorrect for workers. Defining a separate method forces implementers to think about how equivalence is defined. Workers are lifecycle-aware \u00b6 Workers are aware of when they\u2019re started (just like Workflows), but they are also aware of when they are torn down. This makes them handy for managing resources as well.","title":"Worker"},{"location":"userguide/core-worker/#workflow-core-worker","text":"","title":"Workflow Core: Worker"},{"location":"userguide/core-worker/#the-role-of-a-worker","text":"Worker is a protocol (in Swift) and interface (in Kotlin) that defines an asynchronous task that can be performed by a Workflow . Worker s only emit outputs, they do not have a Rendering type. They are similar to child workflows with Void / Unit rendering types. A workflow can ask the infrastructure to await the result of a worker by passing that worker to the RenderContext.runningWorker method within a call to the render method. A workflow can handle outputs from a Worker .","title":"The Role of a Worker"},{"location":"userguide/core-worker/#workers-provide-a-declarative-window-into-the-imperative-world","text":"As nice as it is to write declarative code, real apps need to interact with imperative APIs. Workers allow wrapping imperative APIs so that Workflows can interact with them in a declarative fashion. Instead of making imperative \u201cstart this, do that, now stop\u201d calls, a Workflow can say \u201cI declare that this task should now be running\u201d and let the infrastructure worry about ensuring the task is actually started when necessary, continues running if it was already in flight, and torn down when it\u2019s not needed anymore.","title":"Workers provide a declarative window into the imperative world"},{"location":"userguide/core-worker/#workers-can-perform-side-effects","text":"Unlike workflows\u2019 render method, which can be called many times and must be idempotent, workers are started and then ran until completion (or cancellation) \u2013 independently of how many times the workflow running them is actually rendered. This means that side effects that should be performed only once when a workflow enters a particular state, for example, should be placed into a Worker that the workflow runs while in that state.","title":"Workers can perform side effects"},{"location":"userguide/core-worker/#workers-are-cold-reactive-streams","text":"Workers are effectively simple wrappers around asynchronous streams with explicit equivalence. In Swift, workers are backed by ReactiveSwift SignalProducer s . In Kotlin, they\u2019re backed by Kotlin Flow s . They are also easily derived from Reactive Streams Publishers , including RxJava Observable , Flowable , or Single instances.","title":"Workers are cold reactive streams"},{"location":"userguide/core-worker/#worker-subscriptions-are-managed-automatically","text":"While Workers are backed by reactive streams with library-specific subscription APIs, you never actually subscribe directly to a worker yourself. Instead, a Workflow asks the infrastructure to run a worker, and the infrastructure will take care of initializing and tearing down the subscription as appropriate \u2013 much like how child workflows\u2019 lifetimes are automatically managed by the runtime. This makes it impossible to accidentally leak a subscription to a worker.","title":"Worker subscriptions are managed automatically"},{"location":"userguide/core-worker/#workers-manage-their-own-internal-state","text":"Unlike Workflows, which are effectively collections of functions defining state transitions, Workers represent long-running tasks. For example, Workers commonly execute network requests. The worker\u2019s stream will open a socket and, either blocking on a background thread or asynchronously, read from that socket and eventually emit data to the workflow that is running it.","title":"Workers manage their own internal state"},{"location":"userguide/core-worker/#workers-define-their-own-equivalence","text":"Since Workers represent ongoing tasks, the infrastructure needs to be able to tell when two workers represent the same task (so it doesn\u2019t perform the task twice), or when a worker has changed between render passes such that it needs to be torn down and re-started for the new work. For these reasons, any time a workflow requests that a worker be run in sequential render passes, it is asked to compare itself with its last instance and determine if they are equivalent. In Swift, this is determined by the Worker isEquivalent:to: method. Worker s that conform to Equatable will automatically get an isEquivalent:to: method based on the Equatable implementation. In Kotlin, the Worker interface defines the doesSameWorkAs method which is passed the previous worker. Kotlin: Why don\u2019t Workers use equals ? Worker equivalence is a key part of the Worker API. The default implementation of equals , which just compares object identity, is almost always incorrect for workers. Defining a separate method forces implementers to think about how equivalence is defined.","title":"Workers define their own equivalence"},{"location":"userguide/core-worker/#workers-are-lifecycle-aware","text":"Workers are aware of when they\u2019re started (just like Workflows), but they are also aware of when they are torn down. This makes them handy for managing resources as well.","title":"Workers are lifecycle-aware"},{"location":"userguide/core-workflow/","text":"Workflow Core: Workflow \u00b6 The Role of a Workflow \u00b6 Workflow is a protocol (in Swift) and interface (in Kotlin) that defines the contract for a single node in the workflow hierarchy. Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public protocol Workflow : AnyWorkflowConvertible { associatedtype State associatedtype Output = Never associatedtype Rendering func makeInitialState () -> State func workflowDidChange ( from previousWorkflow : Self , state : inout State ) func render ( state : State , context : RenderContext < Self >) -> Rendering } Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 abstract class StatefulWorkflow < in PropsT , StateT , out OutputT : Any , out RenderingT > : Workflow < PropsT , OutputT , RenderingT > { abstract fun initialState ( props : PropsT , initialSnapshot : Snapshot ? ): StateT open fun onPropsChanged ( old : PropsT , new : PropsT , state : StateT ): StateT = state abstract fun render ( props : PropsT , state : StateT , context : RenderContext < StateT , OutputT > ): RenderingT abstract fun snapshotState ( state : StateT ): Snapshot } Swift: What is AnyWorkflowConvertible ? When a protocol has an associated Self type, Swift requires the use of a type-erasing wrapper to store references to instances of that protocol. AnyWorkflow is such a wrapper for Workflow . AnyWorkflowConvertible is a protocol with a single method that returns an AnyWorkflow . It is useful as a base type because it allows instances of Workflow to be used directly by any code that requires the type-erased AnyWorkflow . Kotlin: StatefulWorkflow vs Workflow It is a common practice in Kotlin to divide types into two parts: an interface for public API, and a class for private implementation. The Workflow library defines a Workflow interface, which should be used as the type of properties and parameters by code that needs to refer to a particular Workflow interface. The Workflow interface contains a single method, which simply returns a StatefulWorkflow \u2013 a Workflow can be described as \u201canything that can be expressed as a StatefulWorkflow .\u201d The library also defines two abstract classes which define the contract for workflows and should be subclassed to implement your workflows: StatefulWorkflow should be subclassed to implement Workflows that have private state . StatelessWorkflow should be subclassed to implement Workflows that don\u2019t have any private state. See Stateless Workflows . Workflows have several responsibilities: Workflows have state \u00b6 Once a Workflow has been started, it always operates in the context of some state. This state is divided into two parts: private state, which only the Workflow implementation itself knows about, which is defined by the State type, and properties (or \u201cprops\u201d), which is passed to the Workflow from its parent (more on hierarchical workflows below). Private state \u00b6 Every Workflow implementation defines a State type to maintain any necessary state while the workflow is running. For example, a tic-tac-toe game might have a state like this: Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 struct State { enum Player { case x case o } enum Space { case unfilled filled ( Player ) } // 3 rows * 3 columns = 9 spaces var spaces : [ Space ] = Array ( repeating : . unfilled , count : 9 ) var currentTurn : Player = . x } Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 data class State ( // 3 rows * 3 columns = 9 spaces val spaces : List < Space > = List ( 9 ) { Unfilled }, val currentTurn : Player = X ) { enum class Player { X , O } sealed class Space { object Unfilled : Space () data class Filled ( val player : Player ) : Space () } } When the workflow is first started, it is queried for an initial state value. From that point forward, the workflow may advance to a new state as the result of events occurring from various sources (which will be covered below). Stateless Workflows If a workflow does not have any private state, it is often referred to as a \u201cstateless workflow\u201d. A stateless Workflow is simply a Workflow that has a Void or Unit State type. See more below . Props \u00b6 Every Workflow implementation also defines data that is passed into it. The Workflow is not able to modify this state itself, but it may change between render passes. This public state is called Props . In Swift, the props are simply defined as properties of the struct implementing Workflow itself. In Kotlin, the Workflow interface defines a separate PropsT type parameter. (This additional type parameter is necessary due to Kotlin\u2019s lack of the Self type that Swift workflow\u2019s workflowDidChange method relies upon.) Swift 1 TK Kotlin 1 2 3 4 data class Props ( val playerXName : String val playerOName : String ) Workflows are advanced by WorkflowAction s \u00b6 Any time something happens that should advance a workflow \u2013 a UI event, a network response, a child\u2019s output event \u2013 actions are used to perform the update. For example, a workflow may respond to UI events by mapping those events into a type conforming to/implementing WorkflowAction . These types implement the logic to advance a workflow by: Advancing to a new state (Optionally) emitting an output event up the tree. WorkflowAction s are typically defined as enums with associated types (Swift) or sealed classes (Kotlin), and can include data from the event \u2013 for example, the ID of the item in the list that was clicked. Side effects such as logging button clicks to an analytics framework are also typically performed in actions. If you\u2019re familiar with React/Redux, WorkflowAction s are essentially reducers. Workflows can emit output events up the hierarchy to their parent \u00b6 When a workflow is advanced by an action, an optional output event can be sent up the workflow hierarchy. This is the opportunity for a workflow to notify its parent that something has happened (and the parent\u2019s opportunity to respond to that event by dispatching its own action, continuing up the tree as long as output events are emitted). Workflows produce an external representation of their state via Rendering \u00b6 Immediately after starting up, or after a state transition occurs, a workflow will have its render method called. This method is responsible for creating and returning a value of type Rendering . You can think of Rendering as the \u201cexternal published state\u201d of the workflow, and the render function as a map of ( Props + State + childrens\u2019 Rendering s) -> Rendering . While a workflow\u2019s internal state may contain more detailed or comprehensive state, the Rendering (external state) is a type that is useful outside of the workflow. Because a workflow\u2019s render method may be called by infrastructure for a variety of reasons, it\u2019s important to not perform side effects when rendering \u2014 render methods must be idempotent. Event-based side effects should use Actions and state-based side effects should use Workers. When building an interactive application, the Rendering type is commonly (but not always) a view model that will drive the UI layer. Workflows can respond to UI events \u00b6 The RenderContext that is passed into render as the last parameter provides some useful tools to assist in creating the Rendering value. If a workflow is producing a view model, it is common to need an event handler to respond to UI events. The RenderContext has API to create an event handler, called a Sink , that when called will advance the workflow by dispatching an action back to the workflow (for more on actions, see below ). Swift 1 2 3 4 5 6 7 8 func render ( state : State , context : RenderContext < DemoWorkflow >) -> DemoScreen { // Create a sink of our Action type so we can send actions back to the workflow. let sink = context . makeSink ( of : Action . self ) return DemoScreen ( title : \"A nice title\" , onTap : { sink . send ( Action . refreshButtonTapped ) } } Kotlin 1 TK Workflows form a hierarchy (they may have children) \u00b6 As they produce a Rendering value, it is common for workflows to delegate some portion of that work to a child workflow . This is done via the RenderContext that is passed into the render method. In order to delegate to a child, the parent calls renderChild on the context, with the child workflow as the single argument. The infrastructure will spin up the child workflow (including initializing its initial state) if this is the first time this child has been used, or, if the child was also used on the previous render pass, the existing child will be updated. Either way, render will immediately be called on the child (by the Workflow infrastructure), and the resulting child\u2019s Rendering value will be returned to the parent. This allows a parent to return complex Rendering types (such as a view model representing the entire UI state of an application) without needing to model all of that complexity within a single workflow. Workflow Identity The Workflow infrastructure automatically detects the first time and the last subsequent time you\u2019ve asked to render a child workflow, and will automatically initialize the child and clean it up. In both Swift and Kotlin, this is done using the workflow\u2019s concrete type. Both languages use reflection to do this comparison (e.g. in Kotlin, the workflows\u2019 KClass es are compared). It is an error to render workflows of the same type more than once in the same render pass. Since type is used for workflow identity, the child rendering APIs take an optional string key to differentiate between multiple child workflows of the same type. Workflows can subscribe to external event sources \u00b6 If a workflow needs to respond to some external event source (e.g. push notifications), the workflow can ask the context to listen to those events from within the render method. Swift vs Kotlin In the Swift library, there is a special API for subscribing to hot streams ( Signal in ReactiveSwift). The Kotlin library does not have any special API for subscribing to hot streams (channels), though it does have extension methods to convert ReceiveChannel s , and RxJava Flowable s and Observables , to Worker s . The reason for this discrepancy is simply that we don\u2019t have any uses of channels yet in production, and so we\u2019ve decided to keep the API simpler. If we start using channels in the future, it may make sense to make subscribing to them a first-class API like in Swift. Workflows can perform asynchronous tasks (Workers) \u00b6 Workers are very similar in concept to child workflows. Unlike child workflows, however, workers do not have a Rendering type; they only exist to perform a single asynchronous task before sending zero or more output events back up the tree to their parent. For more information about workers, see the Worker section below. Workflows can be saved to and restored from a snapshot (Kotlin only) \u00b6 On every render pass, each workflow is asked to create a \u201csnapshot\u201d of its state \u2013 a lazily-produced serialization of the workflow\u2019s State as a binary blob. These Snapshot s are aggregated into a single Snapshot for the entire workflow tree and emitted along with the root workflow\u2019s Rendering . When the workflow runtime is started, it can be passed an optional Snapshot to restore the tree from. When non-null, the root workflow\u2019s snapshot is extracted and passed to the root workflow\u2019s initialState . The workflow can choose to either ignore the snapshot or use it to restore its State . On the first render pass, if the root workflow renders any children that were also being rendered when the snapshot was taken, those children\u2019s snapshots are also extracted from the aggregate and used to initialize their states. !!! faq Why don\u2019t Swift Workflows support snapshotting? Snapshotting was built into Kotlin workflows specifically to support Android\u2019s app lifecycle, which requires apps to serialize their current state before being backgrounded so that they can be restored in case the system needs to kill the hosting process. iOS apps don\u2019t have this requirement, so the Swift library doesn\u2019t need to support it.","title":"Workflow"},{"location":"userguide/core-workflow/#workflow-core-workflow","text":"","title":"Workflow Core: Workflow"},{"location":"userguide/core-workflow/#the-role-of-a-workflow","text":"Workflow is a protocol (in Swift) and interface (in Kotlin) that defines the contract for a single node in the workflow hierarchy. Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public protocol Workflow : AnyWorkflowConvertible { associatedtype State associatedtype Output = Never associatedtype Rendering func makeInitialState () -> State func workflowDidChange ( from previousWorkflow : Self , state : inout State ) func render ( state : State , context : RenderContext < Self >) -> Rendering } Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 abstract class StatefulWorkflow < in PropsT , StateT , out OutputT : Any , out RenderingT > : Workflow < PropsT , OutputT , RenderingT > { abstract fun initialState ( props : PropsT , initialSnapshot : Snapshot ? ): StateT open fun onPropsChanged ( old : PropsT , new : PropsT , state : StateT ): StateT = state abstract fun render ( props : PropsT , state : StateT , context : RenderContext < StateT , OutputT > ): RenderingT abstract fun snapshotState ( state : StateT ): Snapshot } Swift: What is AnyWorkflowConvertible ? When a protocol has an associated Self type, Swift requires the use of a type-erasing wrapper to store references to instances of that protocol. AnyWorkflow is such a wrapper for Workflow . AnyWorkflowConvertible is a protocol with a single method that returns an AnyWorkflow . It is useful as a base type because it allows instances of Workflow to be used directly by any code that requires the type-erased AnyWorkflow . Kotlin: StatefulWorkflow vs Workflow It is a common practice in Kotlin to divide types into two parts: an interface for public API, and a class for private implementation. The Workflow library defines a Workflow interface, which should be used as the type of properties and parameters by code that needs to refer to a particular Workflow interface. The Workflow interface contains a single method, which simply returns a StatefulWorkflow \u2013 a Workflow can be described as \u201canything that can be expressed as a StatefulWorkflow .\u201d The library also defines two abstract classes which define the contract for workflows and should be subclassed to implement your workflows: StatefulWorkflow should be subclassed to implement Workflows that have private state . StatelessWorkflow should be subclassed to implement Workflows that don\u2019t have any private state. See Stateless Workflows . Workflows have several responsibilities:","title":"The Role of a Workflow"},{"location":"userguide/core-workflow/#workflows-have-state","text":"Once a Workflow has been started, it always operates in the context of some state. This state is divided into two parts: private state, which only the Workflow implementation itself knows about, which is defined by the State type, and properties (or \u201cprops\u201d), which is passed to the Workflow from its parent (more on hierarchical workflows below).","title":"Workflows have state"},{"location":"userguide/core-workflow/#private-state","text":"Every Workflow implementation defines a State type to maintain any necessary state while the workflow is running. For example, a tic-tac-toe game might have a state like this: Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 struct State { enum Player { case x case o } enum Space { case unfilled filled ( Player ) } // 3 rows * 3 columns = 9 spaces var spaces : [ Space ] = Array ( repeating : . unfilled , count : 9 ) var currentTurn : Player = . x } Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 data class State ( // 3 rows * 3 columns = 9 spaces val spaces : List < Space > = List ( 9 ) { Unfilled }, val currentTurn : Player = X ) { enum class Player { X , O } sealed class Space { object Unfilled : Space () data class Filled ( val player : Player ) : Space () } } When the workflow is first started, it is queried for an initial state value. From that point forward, the workflow may advance to a new state as the result of events occurring from various sources (which will be covered below). Stateless Workflows If a workflow does not have any private state, it is often referred to as a \u201cstateless workflow\u201d. A stateless Workflow is simply a Workflow that has a Void or Unit State type. See more below .","title":"Private state"},{"location":"userguide/core-workflow/#props","text":"Every Workflow implementation also defines data that is passed into it. The Workflow is not able to modify this state itself, but it may change between render passes. This public state is called Props . In Swift, the props are simply defined as properties of the struct implementing Workflow itself. In Kotlin, the Workflow interface defines a separate PropsT type parameter. (This additional type parameter is necessary due to Kotlin\u2019s lack of the Self type that Swift workflow\u2019s workflowDidChange method relies upon.) Swift 1 TK Kotlin 1 2 3 4 data class Props ( val playerXName : String val playerOName : String )","title":"Props"},{"location":"userguide/core-workflow/#workflows-are-advanced-by-workflowactions","text":"Any time something happens that should advance a workflow \u2013 a UI event, a network response, a child\u2019s output event \u2013 actions are used to perform the update. For example, a workflow may respond to UI events by mapping those events into a type conforming to/implementing WorkflowAction . These types implement the logic to advance a workflow by: Advancing to a new state (Optionally) emitting an output event up the tree. WorkflowAction s are typically defined as enums with associated types (Swift) or sealed classes (Kotlin), and can include data from the event \u2013 for example, the ID of the item in the list that was clicked. Side effects such as logging button clicks to an analytics framework are also typically performed in actions. If you\u2019re familiar with React/Redux, WorkflowAction s are essentially reducers.","title":"Workflows are advanced by WorkflowActions"},{"location":"userguide/core-workflow/#workflows-can-emit-output-events-up-the-hierarchy-to-their-parent","text":"When a workflow is advanced by an action, an optional output event can be sent up the workflow hierarchy. This is the opportunity for a workflow to notify its parent that something has happened (and the parent\u2019s opportunity to respond to that event by dispatching its own action, continuing up the tree as long as output events are emitted).","title":"Workflows can emit output events up the hierarchy to their parent"},{"location":"userguide/core-workflow/#workflows-produce-an-external-representation-of-their-state-via-rendering","text":"Immediately after starting up, or after a state transition occurs, a workflow will have its render method called. This method is responsible for creating and returning a value of type Rendering . You can think of Rendering as the \u201cexternal published state\u201d of the workflow, and the render function as a map of ( Props + State + childrens\u2019 Rendering s) -> Rendering . While a workflow\u2019s internal state may contain more detailed or comprehensive state, the Rendering (external state) is a type that is useful outside of the workflow. Because a workflow\u2019s render method may be called by infrastructure for a variety of reasons, it\u2019s important to not perform side effects when rendering \u2014 render methods must be idempotent. Event-based side effects should use Actions and state-based side effects should use Workers. When building an interactive application, the Rendering type is commonly (but not always) a view model that will drive the UI layer.","title":"Workflows produce an external representation of their state via Rendering"},{"location":"userguide/core-workflow/#workflows-can-respond-to-ui-events","text":"The RenderContext that is passed into render as the last parameter provides some useful tools to assist in creating the Rendering value. If a workflow is producing a view model, it is common to need an event handler to respond to UI events. The RenderContext has API to create an event handler, called a Sink , that when called will advance the workflow by dispatching an action back to the workflow (for more on actions, see below ). Swift 1 2 3 4 5 6 7 8 func render ( state : State , context : RenderContext < DemoWorkflow >) -> DemoScreen { // Create a sink of our Action type so we can send actions back to the workflow. let sink = context . makeSink ( of : Action . self ) return DemoScreen ( title : \"A nice title\" , onTap : { sink . send ( Action . refreshButtonTapped ) } } Kotlin 1 TK","title":"Workflows can respond to UI events"},{"location":"userguide/core-workflow/#workflows-form-a-hierarchy-they-may-have-children","text":"As they produce a Rendering value, it is common for workflows to delegate some portion of that work to a child workflow . This is done via the RenderContext that is passed into the render method. In order to delegate to a child, the parent calls renderChild on the context, with the child workflow as the single argument. The infrastructure will spin up the child workflow (including initializing its initial state) if this is the first time this child has been used, or, if the child was also used on the previous render pass, the existing child will be updated. Either way, render will immediately be called on the child (by the Workflow infrastructure), and the resulting child\u2019s Rendering value will be returned to the parent. This allows a parent to return complex Rendering types (such as a view model representing the entire UI state of an application) without needing to model all of that complexity within a single workflow. Workflow Identity The Workflow infrastructure automatically detects the first time and the last subsequent time you\u2019ve asked to render a child workflow, and will automatically initialize the child and clean it up. In both Swift and Kotlin, this is done using the workflow\u2019s concrete type. Both languages use reflection to do this comparison (e.g. in Kotlin, the workflows\u2019 KClass es are compared). It is an error to render workflows of the same type more than once in the same render pass. Since type is used for workflow identity, the child rendering APIs take an optional string key to differentiate between multiple child workflows of the same type.","title":"Workflows form a hierarchy (they may have children)"},{"location":"userguide/core-workflow/#workflows-can-subscribe-to-external-event-sources","text":"If a workflow needs to respond to some external event source (e.g. push notifications), the workflow can ask the context to listen to those events from within the render method. Swift vs Kotlin In the Swift library, there is a special API for subscribing to hot streams ( Signal in ReactiveSwift). The Kotlin library does not have any special API for subscribing to hot streams (channels), though it does have extension methods to convert ReceiveChannel s , and RxJava Flowable s and Observables , to Worker s . The reason for this discrepancy is simply that we don\u2019t have any uses of channels yet in production, and so we\u2019ve decided to keep the API simpler. If we start using channels in the future, it may make sense to make subscribing to them a first-class API like in Swift.","title":"Workflows can subscribe to external event sources"},{"location":"userguide/core-workflow/#workflows-can-perform-asynchronous-tasks-workers","text":"Workers are very similar in concept to child workflows. Unlike child workflows, however, workers do not have a Rendering type; they only exist to perform a single asynchronous task before sending zero or more output events back up the tree to their parent. For more information about workers, see the Worker section below.","title":"Workflows can perform asynchronous tasks (Workers)"},{"location":"userguide/core-workflow/#workflows-can-be-saved-to-and-restored-from-a-snapshot-kotlin-only","text":"On every render pass, each workflow is asked to create a \u201csnapshot\u201d of its state \u2013 a lazily-produced serialization of the workflow\u2019s State as a binary blob. These Snapshot s are aggregated into a single Snapshot for the entire workflow tree and emitted along with the root workflow\u2019s Rendering . When the workflow runtime is started, it can be passed an optional Snapshot to restore the tree from. When non-null, the root workflow\u2019s snapshot is extracted and passed to the root workflow\u2019s initialState . The workflow can choose to either ignore the snapshot or use it to restore its State . On the first render pass, if the root workflow renders any children that were also being rendered when the snapshot was taken, those children\u2019s snapshots are also extracted from the aggregate and used to initialize their states. !!! faq Why don\u2019t Swift Workflows support snapshotting? Snapshotting was built into Kotlin workflows specifically to support Android\u2019s app lifecycle, which requires apps to serialize their current state before being backgrounded so that they can be restored in case the system needs to kill the hosting process. iOS apps don\u2019t have this requirement, so the Swift library doesn\u2019t need to support it.","title":"Workflows can be saved to and restored from a snapshot (Kotlin only)"},{"location":"userguide/implementation/","text":"Implementation Notes \u00b6 Coming soon!","title":"Under the Hood: Implementation Notes"},{"location":"userguide/implementation/#implementation-notes","text":"Coming soon!","title":"Implementation Notes"},{"location":"userguide/motivation/","text":"Motivation & Architectural Concepts \u00b6 Coming soon!","title":"Motivation & Architectural Concepts"},{"location":"userguide/motivation/#motivation-architectural-concepts","text":"Coming soon!","title":"Motivation &amp; Architectural Concepts"},{"location":"userguide/testing-concepts/","text":"Workflow Testing \u00b6 Coming soon!","title":"Workflow Testing"},{"location":"userguide/testing-concepts/#workflow-testing","text":"Coming soon!","title":"Workflow Testing"},{"location":"userguide/ui-concepts/","text":"Workflow UI \u00b6 Coming soon!","title":"Workflow UI"},{"location":"userguide/ui-concepts/#workflow-ui","text":"Coming soon!","title":"Workflow UI"}]}